---
title: 索引（2）
date: 2020-06-25 20:53:06
tags: [MySQL]
declare: true
---
本文探讨**多列索引（类型为B-TREE）**对哪些查询有效
Mysql版本为5.7 
下面的sql均是基于下表~
```
CREATE TABLE `emp` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `num` int(11) NOT NULL,
  `name` varchar(20) DEFAULT NULL,
  `age` int(3) DEFAULT NULL,
  `dept_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE INDEX idx_age_deptid_name ON emp(age,dept_id,name)
```
### explain关键字

 ![avatar](/images/index/explain.png)

+ possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用。
+ key：**实际使用的索引。如果为NULL，则没有使用索引**。
+ key_len：表示索引中使用的字节数，能够帮你检查是否充分的利用上了索引。
+ extra：重要的额外信息
    * Using filesort：无法使用索引排序，使用效率低的文件排序
    * Using temporary：使用临时表保存中间结果,常见于 order by 和 group by
    * Using index condition：使用索引条件下推（5.6加入）
    * Using index：使用覆盖索引，不需要回表
    * Using where
    * Using join buffer
    * impossible where
    * select tables optimized away

### 最左前缀原则
如果索引了多列，**查询从索引的最左列开始并且不跳过索引中的列。**
![avatar](/images/index/left1.png)

![avatar](/images/index/left2.png)

![avatar](/images/index/left3.png)

图2由于不是从索引最左列开始，所以没有用到索引（key为NULL）
图3虽然用到了索引，但是跳过了dept_id，只用到了索引的一部分（key_len 5 < 93）

### 不在索引列上做任何操作(索引不能是表达式的一部分)
计算、函数、(自动or手动)类型转换，会导致索引失效
![avatar](/images/index/oper1.png)

![avatar](/images/index/oper2.png)

![avatar](/images/index/oper3.png)

图1由于在索引上计算导致无法使用索引
图2由于在索引上使用了函数导致无法使用索引
图3由于在name上有类型转换（**name为varchar，123没有引号**），导致name失效（key_len 10< 93）

### 范围条件右侧的列无法使用索引
![avatar](/images/index/range.png)
由于age使用范围查询，所以无法使用范围查询右侧的dept_id和name（key_len 5 < 93）

### 不等于无法使用索引
![avatar](/images/index/notequal.png)
由于age使用了不等于，所以无法使用索引

### is not null无法使用索引，is null可以
![avatar](/images/index/isnotnull.png)

### like以通配符开头不能使用索引，以通配符结束可以
![avatar](/images/index/like.png)
