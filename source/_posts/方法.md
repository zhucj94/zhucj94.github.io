---
title: 方法
date: 2020-03-30 19:09:10
tags: [effective java 3rd , 读书笔记]
declare: true
---
### 检查参数有效性
+ 大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。例如，索引值必须是非负数。***在方法的开头检查参数，抛出适当的异常快速且清楚的结束方法***。如果不检查参数，可能会出现令人困惑的异常，或者方法正常返回，但计算错误。
+ 可以使用guava的Preconditions检查参数。
<!-- more -->

### 必要时进行防御性拷贝
```java
    public final class Period {
        private final Date start;
        private final Date end;
        public Period(Date start, Date end) {
            if (start.compareTo(end) > 0)
                throw new IllegalArgumentException(
                    start + " after " + end);
                    this.start = start;
            this.end = end;
        }
        public Date start() {
            return start;
        }
        public Date end() {
            return end;
        } 
        ...
    }
```
+ ***假定类的客户端尽力摧毁类不变量，防御性地编写程序。***Period看起来是不可变的，但是利用Date的可变性，就能打破不变性。
```java
 new Period(new Date(), new Date()).end().setYear(78);
```

```java
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
        if (this.start.compareTo(this.end) > 0)
            throw new IllegalArgumentException(
                    this.start + " after " + this.end);
    }

    public Date start() {
        return new Date(start.getTime());
    }
    public Date end() {
        return new Date(end.getTime());
    }
```
使用新的构造方法和新的访问器，Period是真正不可变的。在可能的情况下，应该使用不可变对象作为对象的组件，如Period中使用LocalDateTime，就不用做防御性拷贝。
***防御性拷贝是在检查参数的有效性之前进行的***，有效性检查是在拷贝上而不是在原始实例上进行的,这样检查参数和拷贝参数之间的漏洞窗口期间保护类不受其他线程对参数的更改的影响，这称为time-of-check/time-of-use 或 TOCTOU 攻击。
+ 如果拷贝的成本太高，并且类信任它的客户端不会不适当地修改组件，则可以用文档替换防御性拷贝，该文档概述了客户端不得修改受影响组件。

### 仔细设计方法签名
+ 仔细选择方法名，选择与同一包中的其他名称一致且易于理解的名称，避免使用较长的方法名，可以参考 Java 类库API
+ 不要过分地提供方便的方法，太多的方法使得类难以使用和维护，对于类或接口支持的每个操作，
提供一个功能完整的方法。
+ 避免过长的参数列表，尽量是4个及以下的参数，过多的参数会使方法难以使用。有3种技术可以缩短列表
    + 创建辅助类保存参数组，这些辅助类通常是静态内部类。
    + 将方法分解为多个方法，每个方法只需要参数的一个子集。例如List没有提供子列表中元素的第一个或最后一个索引位置，但是可以结合subList，indexOf，lastIndexOf使用。
    + Builder模式，定义一个对象来表示所有的参数，并允许客户端在这个对象上进行多个"setter" 调用，设置好所需的参数后，客户端调用对象的"execute"方法，该方法对参数进行最后的有效性检查，并执行实际的计算。
+ 与布尔型参数相比，优先使用两个元素枚举类型，除非布尔型参数的含义在方法名中是明确的。

### 明智审慎地使用重载
```java
   public class CollectionClassifier {
        public static String classify(Set<?> s) {
            return "Set";
        }

        public static String classify(List<?> lst) {
            return "List";
        }

        public static String classify(Collection<?> c) {
            return "Unknown Collection";
        }

        public static void main(String[] args) {
            Collection<?>[] collections = {
                    new HashSet<String>(),
                    new ArrayList<BigInteger>(),
                    new HashMap<String, String>().values()
            };
            for (Collection<?> c : collections)
                System.out.println(classify(c));
        }
    }
```
+ 这个main方法将输出三次Unknown Collection，因为classify方法被重载了，***在编译时选择要调用哪个重载方法。***
+ 重载（overloaded）方法之间的选择是静态的，***而重写（overridden）方法之间的选择是动态的。重写总是会执行“最具体 (most specific)”的重写方法。***
+ ***一个安全和保守的策略是永远不要导出两个具有相同参数数量的重载，可以为方法赋予不同的名称，而不是重载它们。***例如ObjectOutputStream的writeBoolean(boolean)，writeFloat(float)。
+ 类的多个构造函数总是被重载，可以使用静态工厂方法而不是构造。
+ 不要在相同参数位置重载采用不同函数式接口的方法。例如Executors.submit(Callable),Executors.submit(Runnable)。
```java
Executors.newCachedThreadPool().submit(System.out::println)//无法编译Ambiguous method
```
Runnable.run()返回是void，println返回是void，看起来应该能编译，但并不能。

### 明智审慎地使用可变参数
```java
int sum(int... args) {
    int sum = 0;
    for (int arg : args)
        sum += arg;
    return sum;
}
```
+ 在需要参数数量可变的方法时，可变参数是有效的,在性能关键的情况下使用可变参数时要小心。每次调用可变参数方法都会导致数组分配和初始化。假设你已确定95％的调用是三个或更少的参数的方法，那么声明该方法的五个重载。例如guava的ImmutableMap静态工厂方法of。
```java
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1) { }

  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2) { }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)( }
  
  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { }

  public static <K, V> ImmutableMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5){ }
```

### 返回空的数组或集合，不要返回 null
+ 在几乎每次使用返回 null 来代替空集合或数组的方法时，都需要判断非空。
+ 如果有证据表明分配空集合会损害性能，可以通过重复返回相同的不可变空集合来避免分配，例如Collections.emptyList。

### 明智审慎地返回 Optional
+ 在 Java 8 中加入了 Optional&lt;T&gt;，返回Optional的方法比抛出异常的方法更灵活、更容易使用，而且比返回 null 的方法更不容易出错。
```java
    public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
        if (c.isEmpty())
            return Optional.empty();
        E result = null;
        for (E e : c)
            if (result == null || e.compareTo(result) > 0)
                result = Objects.requireNonNull(e);
        return Optional.of(result);
    }

    String lastWordInLexicon = max(words).orElse("No words...");
```
Optional很简单,Optional.empty() 返回一个空的 Optional， Optional.of(value)返回一个包含给定非null值的Optional，不要将null传入of方法，这将会抛出NullPointerException。
***永远不要通过返回 Optional 的方法返回一个null***，这违反了Optional设计初衷。
Optional迫使用户面对可能没有返回值的事实，抛出未抛出未检查的异常或返回null允许用户忽略这种可能性，从而带来潜在的错误。抛出一个检查异常需要在客户端中添加额外的代码。
+ 容器类型，包括集合、映射、Stream、数组和Optional，不应该封装在Optional中，与其返回一个空的 Optional<List<T>> ，不还如返回一个空的 List<T>。
+ 通常，***如果可能无法返回结果，并且在没有返回结果，客户端还必须执行特殊处理的情况下，则应声明返回 Optional 的方法。***