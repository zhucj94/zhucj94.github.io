---
title: 异常
date: 2020-04-02 14:22:14
tags: [effective java 3rd , 读书笔记]
declare: true
---
### 对可恢复的情况使用受检异常，对编程错误使用运行时异常
+ 如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。
+ 用运行时异常来表明编程错误，例如数组的下标值在0到长度-1之间，ArrayIndexOutOfBoundsException表明违反了这个前提。按照惯例，***错误（Error）往往被JVM保留下来使用，你实现的所有非受检的 throwable 都应该是 RuntimeExceptiond 子类。***
<!-- more -->

### 避免不必要的使用受检异常
+ 在谨慎使用的前提之下，受检异常可以提升程序的可读性；过分使用受检异常使api不方便，api必须位于try块中或者方法向上抛出异常。
+ 可以使用下面两种方式部分替代受检异常。
    + 返回一个Optional，方法不抛出异常，只是返回一个空Optional，缺点是方法无法返回额外信息，而异常可以。
    + 将受检异常变为非受检异常，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个boolean值，表明是否应该抛出异常，第二个方法正常执行，抛出非受检异常。
```
try {
    obj.action( args );
} catch ( TheCheckedException e ) {
... /* Handle exceptional condition */
}
重构为下面
if ( obj.actionPermitted( args ) ) {
    obj.action( args );
} else {
... /* Handle exceptional condition */
}
```
这种重构并非总是恰当的，如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在actionPermitted和action这两个调用的时间间隔之中，对象的状态有可能会发生变化。如果单独的actionPermitted方法必须重复action方法的工作，出于性能的考虑，这种API重构就不值得去做。

### 抛出与抽象对应的异常
+ 如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抛出的异常时，往往会发生这种情况，为了避免这个问题，更高层的实现应该***捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为异常转译(exception translation)***，例如AbstractSequentialList.get(index)。
```
    public E get(int index) {
        try {
            return listIterator(index).next();
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
```
+ ***尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它。***处理来自低层异常的最好做法是在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常，例如给低层传递参数之前，检查更高层方法的参数的有效性。其次的做法是，让更高层来悄悄地处理这些异常，从而将高层方法的调用者与低层的问题隔离开来，例如日志打印。

### 保证失败原子性
+ 一般而言，***失败的方法调用应该使对象保持在被调用之前的状态。***具有这种属性的方法被称为具有失败原子性 (failure atomic)。
+ 有5中方法保持失败原子性
    * 使用不可变对象。
    * 在执行操作之前检查参数的有效性，例如Arraylist.get(index)。
    ```
      public E get(int index) {
        rangeCheck(index);
        return elementData(index);
      }

      private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
      }
    ```
    * 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。
    * 在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。
    * 编写一段恢复代码 (recoverycode)，由它来拦截操作过程中发生的失败，以及便对象回滚到操作开始之前的状态上。