<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小朱的blog</title>
  
  <subtitle>及时当勉励，岁月不待人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhucj94.github.io/"/>
  <updated>2020-07-24T15:56:46.665Z</updated>
  <id>https://zhucj94.github.io/</id>
  
  <author>
    <name>飞光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis源码之一级缓存</title>
    <link href="https://zhucj94.github.io/article/7dd9b5ec.html"/>
    <id>https://zhucj94.github.io/article/7dd9b5ec.html</id>
    <published>2020-07-19T09:39:32.000Z</published>
    <updated>2020-07-24T15:56:46.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。</p><hr><p>MyBatis一级缓存的核心逻辑位于<strong>BaseExecutor</strong>中</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PerpetualCache localCache</span><br></pre></td></tr></table></figure><p>PerpetualCache是通过HashMap来存储的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>localCache的key是CacheKey对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLIER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line">  <span class="comment">//hash计算时乘的倍数,默认构造会赋值DEFAULT_MULTIPLIER</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier; </span><br><span class="line">  <span class="comment">//hash码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode; </span><br><span class="line">  <span class="comment">//不乘倍数的hash码累加值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="comment">//调用update方法的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//所有update对象</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 每次update便修改hashcode，count，checksum，updateList</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 比较hashcode，count，checksum，updateList</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的命中条件"><a href="#缓存的命中条件" class="headerlink" title="缓存的命中条件"></a>缓存的命中条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  <span class="comment">//1.方法名</span></span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  <span class="comment">//2.偏移量</span></span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  <span class="comment">//3.查询数量上限</span></span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  <span class="comment">//4.sql</span></span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.参数</span></span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//6.环境</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出一级缓存命中条件是</p><ol><li><strong>相同的方法（MappedStatement）</strong></li><li><strong>相同sql，参数</strong></li><li><strong>相同查询范围，即偏移量，limit</strong></li><li><strong>相同的session</strong>，此代码中未体现，但是localCache在BaseExecutor中，而BaseExecutor的创建是在初始化session时（入口是SqlSessionFactory.opensession，具体方法是Configuration.newExecutor）</li></ol><h3 id="缓存清除条件"><a href="#缓存清除条件" class="headerlink" title="缓存清除条件"></a>缓存清除条件</h3><p>PerpetualCache通过clear方法来清空缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用情况如下图<br><img src="/images/mybatis/first_cache_clear.png" alt="avatar"></p><ol><li>回滚</li><li>提交</li><li>修改</li><li>查询，当设置flushCache=”true”时，默认为false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>由于事务提交会清除缓存，所以要用到一级缓存，还需要在同一事务中</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;MyBatis一级缓存的核心逻辑位于&lt;strong&gt;BaseExecutor&lt;/strong&gt;中&lt;/p&gt;&lt;h3 id=&quot;存储结构&quot;&gt;&lt;a href=&quot;#存储结构&quot; class=&quot;headerlink&quot; title=&quot;存储结构&quot;&gt;&lt;/a&gt;存储结构&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; PerpetualCache localCache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;PerpetualCache是通过HashMap来存储的&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PerpetualCache&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cache&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;Object, Object&amp;gt; cache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://zhucj94.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="https://zhucj94.github.io/article/47519a60.html"/>
    <id>https://zhucj94.github.io/article/47519a60.html</id>
    <published>2020-07-14T13:56:29.000Z</published>
    <updated>2020-07-24T06:18:36.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化数据类型的原则"><a href="#优化数据类型的原则" class="headerlink" title="优化数据类型的原则"></a>优化数据类型的原则</h3><ul><li><p>更小的通常更好<br>更小的数据类型通常更快，因为其占用更少的磁盘，内存，CPU缓存，处理时需要的CPU周期也更少。</p></li><li><p>简单就好<br>简单的数据类型的操作通常需要更少的CPU，例如整型比字符串操作代价低，因为字符集和排序规则使字符比较比整型比较更复杂。</p></li><li><p>尽量避免NULL<br>可为NULL的列使索引，索引统计和值的比较更为复杂，当可为NULL的列被索引时，每个索引需额外的一个字节。</p></li></ul><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT，分别使用8，16，24，32，64位存储空间，范围从$-2^{N-1}$ 到 $2^{N-1} -1$ ，可选UNSIGNED属性，即不允许负，这样正数上线提高一倍。</p><p><strong>指定的宽度通常是没有意义的，例如INT(11)，它不会限制值的合法范围，只规定MySQL交互工具来显示字符个数。</strong></p><h3 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h3><p>DECIMAL，FLOAT，DOUBLE<br>DECIMAL用于存储精确的小数，5.0以后支持精确计算。通常DECIMAL比FLOAT，DOUBLE占用更多的空间。因为需要额外的空间和计算开销，<strong>尽量只在对小数进行精确计算时使用DECIMAL（例如钱），其余情况使用浮点型即可，在数据量比较大时，可以考虑使用BIGINT代替DECIMAL，将存储的数据乘相应位数存储。</strong></p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>VARCHAR 与 CHAR<br>VARCHAR<strong>是变长的</strong>，它仅需要使用必要的空间，它需要使用1或2个字节表示字符串的长度，它节约了空间，但是UPDATE可能使行比原来更长，占用的空间更大，如果页内没有空余的空间存储，那么InnoDB需要分裂页使行放进页中。</li></ul><p>CHAR是<strong>定长的</strong>，MySQL总是根据定义的字符串长度分配足够的空间，MySQL会<strong>删除末尾的空格</strong>，它适合存储所有值都接近同一长度，例如密码的MD5值。</p><ul><li>BLOB 与 TEXT<br>BLOB与TEXT仅有大的不同是BLOB是二进制，而TEXT是字符集，TEXT有字符集和排序规则，而BLOB没有。</li></ul><p>MySQL只对BLOB和TEXT的最前max_sort_length字节排序，而不是整个字符串。</p><ul><li>ENUM<br>ENUM把一些不重复的字符串存储成一个预定义的集合，MySQL存储ENUM时非常紧凑，会将值压缩到一个或两个字节中。<strong>MySQL实际存储ENUM为整数，而不是字符串，表示其在集合中的位置。</strong></li></ul><p>ENUM按照存储的整数进行排序，而不是定义的字符串。</p><p>添加或删除字符串只能用ALTER TABLE，对于未来会发生改变的字符串，使用枚举不太好。<br>ENUM与VARCHAR进行关联查询时，效率会变低，可能原因是ENUM关联时进行了一次转化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化数据类型的原则&quot;&gt;&lt;a href=&quot;#优化数据类型的原则&quot; class=&quot;headerlink&quot; title=&quot;优化数据类型的原则&quot;&gt;&lt;/a&gt;优化数据类型的原则&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;更小的通常更好&lt;br&gt;更小的数据类型通常更快，因为其占用更少的磁盘，
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL第3版" scheme="https://zhucj94.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC3%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引（2）</title>
    <link href="https://zhucj94.github.io/article/be964bf6.html"/>
    <id>https://zhucj94.github.io/article/be964bf6.html</id>
    <published>2020-06-25T12:53:06.000Z</published>
    <updated>2020-07-24T06:18:36.278Z</updated>
    
    <content type="html"><![CDATA[<p>本文探讨<strong>多列索引（类型为B-TREE）</strong>对哪些查询有效<br>Mysql版本为5.7<br>下面的sql均是基于下表~</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`emp`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`num`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`dept_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_age_deptid_name <span class="keyword">ON</span> emp(age,dept_id,<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><h3 id="explain关键字"><a href="#explain关键字" class="headerlink" title="explain关键字"></a>explain关键字</h3><p><img src="/images/index/explain.png" alt="avatar"></p><ul><li>possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用。</li><li>key：<strong>实际使用的索引。如果为NULL，则没有使用索引</strong>。</li><li>key_len：表示索引中使用的字节数，能够帮你检查是否充分的利用上了索引。</li><li>extra：重要的额外信息<ul><li>Using filesort：无法使用索引排序，使用效率低的文件排序</li><li>Using temporary：使用临时表保存中间结果,常见于 order by 和 group by</li><li>Using index condition：使用索引条件下推（5.6加入）</li><li>Using index：使用覆盖索引，不需要回表</li><li>Using where</li><li>Using join buffer</li><li>impossible where</li><li>select tables optimized away</li></ul></li></ul><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>如果索引了多列，<strong>查询从索引的最左列开始并且不跳过索引中的列。</strong><br><img src="/images/index/left1.png" alt="avatar"></p><p><img src="/images/index/left2.png" alt="avatar"></p><p><img src="/images/index/left3.png" alt="avatar"></p><p>图2由于不是从索引最左列开始，所以没有用到索引（key为NULL）<br>图3虽然用到了索引，但是跳过了dept_id，只用到了索引的一部分（key_len 5 &lt; 93）</p><h3 id="不在索引列上做任何操作-索引不能是表达式的一部分"><a href="#不在索引列上做任何操作-索引不能是表达式的一部分" class="headerlink" title="不在索引列上做任何操作(索引不能是表达式的一部分)"></a>不在索引列上做任何操作(索引不能是表达式的一部分)</h3><p>计算、函数、(自动or手动)类型转换，会导致索引失效<br><img src="/images/index/oper1.png" alt="avatar"></p><p><img src="/images/index/oper2.png" alt="avatar"></p><p><img src="/images/index/oper3.png" alt="avatar"></p><p>图1由于在索引上计算导致无法使用索引<br>图2由于在索引上使用了函数导致无法使用索引<br>图3由于在name上有类型转换（<strong>name为varchar，123没有引号</strong>），导致name失效（key_len 10&lt; 93）</p><h3 id="范围条件右侧的列无法使用索引"><a href="#范围条件右侧的列无法使用索引" class="headerlink" title="范围条件右侧的列无法使用索引"></a>范围条件右侧的列无法使用索引</h3><p><img src="/images/index/range.png" alt="avatar"><br>由于age使用范围查询，所以无法使用范围查询右侧的dept_id和name（key_len 5 &lt; 93）</p><h3 id="不等于无法使用索引"><a href="#不等于无法使用索引" class="headerlink" title="不等于无法使用索引"></a>不等于无法使用索引</h3><p><img src="/images/index/notequal.png" alt="avatar"><br>由于age使用了不等于，所以无法使用索引</p><h3 id="is-not-null无法使用索引，is-null可以"><a href="#is-not-null无法使用索引，is-null可以" class="headerlink" title="is not null无法使用索引，is null可以"></a>is not null无法使用索引，is null可以</h3><p><img src="/images/index/isnotnull.png" alt="avatar"></p><h3 id="like以通配符开头不能使用索引，以通配符结束可以"><a href="#like以通配符开头不能使用索引，以通配符结束可以" class="headerlink" title="like以通配符开头不能使用索引，以通配符结束可以"></a>like以通配符开头不能使用索引，以通配符结束可以</h3><p><img src="/images/index/like.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文探讨&lt;strong&gt;多列索引（类型为B-TREE）&lt;/strong&gt;对哪些查询有效&lt;br&gt;Mysql版本为5.7&lt;br&gt;下面的sql均是基于下表~&lt;/p&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引（1)</title>
    <link href="https://zhucj94.github.io/article/b5580210.html"/>
    <id>https://zhucj94.github.io/article/b5580210.html</id>
    <published>2020-06-23T08:43:54.000Z</published>
    <updated>2020-07-24T06:18:36.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><ul><li><p>前缀索引<br>前缀索引是一种能使索引更小，更快的方式，即只索引开始的部分字符，这样可以节约索引空间，提高索引效率。<br>对于BLOB，TEXT，很长的VARCHAR列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept <span class="keyword">add</span> <span class="keyword">key</span>(<span class="keyword">name</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>但是这也会降低索引选择性。</p></li><li><p>索引选择性</p></li></ul><p><strong>不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高</strong>，因为选择性高的索引能让MySQL在查找时过滤更多的行。</p><ul><li>计算索引选择性<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">3</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel3,</span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">4</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel4,</span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">5</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel5</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    dept</span><br></pre></td></tr></table></figure>一般来说能够接近0.031，基本就可用。</li></ul><h3 id="多列索引及索引列的顺序"><a href="#多列索引及索引列的顺序" class="headerlink" title="多列索引及索引列的顺序"></a>多列索引及索引列的顺序</h3><ul><li>多列索引<br>即索引包含多列，例如下篇文章的idx_age_deptid_name</li></ul><p>在多个列上建立独立的单列索引大部分情况并不能提高查询性能（查询条件不止一个的情况），因为<strong>早期MySQL只能使用其中一个单列索引，5.0后引入了索引合并（index merge）策略，即可以同时使用几个索引，并将结果合并，但是在合并操作上会耗费大量资源，且MySQL还遵循range优先原则，即一个索引的连续段包含所有符合查询条件的索引时，不使用索引合并</strong>。</p><ul><li>多列索引顺序经验法则<br>将选择性最高的列放到索引最前列</li></ul><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引不是一种索引类型，而是一种数据存储方式。<br>InnoDB的聚簇索引实际上在<strong>同一结构中保存了B-Tree索引和数据行</strong>，即当表有聚簇索引时，数据行实际存放在索引的叶子页中。</p><p><img src="/images/index/clustered_index.png" alt="avatar"></p><p><strong>InnoDB一定会有聚簇索引</strong>，有主键时就是主键，没有定义主键，InnoDB会选择唯一的非空索引代替，如有没有这样的索引，会隐式定义一个主键。</p><ul><li><p>缺点</p><ul><li>插入速度依赖插入顺序，如果不按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE重新组织表。下面两张图分别为id为递增和UUID的情况。<br><img src="/images/index/insert2.png" alt="avatar"></li></ul><p><img src="/images/index/insert1.png" alt="avatar"></p><ul><li>更新聚簇索引列代价高，因为会强制将被更新的行移动到新位置。</li><li>可能会有‘页分裂（page split）’问题，当行插入到某个已满的页中，存储引擎会将页分裂成两个页，这会导致表占用更多的空间。</li><li><strong>InnoDB的二级索引会有‘回表’问题，因为二级索引叶子节点保存的是行的主键值，而不是‘行指针’，所以使用二级索引的查询需要先找到二级索引的叶子节点获取主键值，然后去聚簇索引查找对应的行。</strong></li></ul></li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含所有需要查询的字段的值，就称为覆盖索引，MySQL只能用B-TREE索引做覆盖索引，因为只有B-TREE索引存储了索引列的值。</p><p><strong>如果InnoDB的查询能用到覆盖索引，那么就可以避免‘回表’。</strong></p><p>如果查询的列由索引和主键组成，也是覆盖索引，因为二级索引的叶子节点保存了主键值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前缀索引和索引选择性&quot;&gt;&lt;a href=&quot;#前缀索引和索引选择性&quot; class=&quot;headerlink&quot; title=&quot;前缀索引和索引选择性&quot;&gt;&lt;/a&gt;前缀索引和索引选择性&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;前缀索引&lt;br&gt;前缀索引是一种能使索引更小，更快的方式，即只
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL第3版" scheme="https://zhucj94.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC3%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB之缓冲池(buffer pool)</title>
    <link href="https://zhucj94.github.io/article/3e77f45e.html"/>
    <id>https://zhucj94.github.io/article/3e77f45e.html</id>
    <published>2020-06-11T14:20:10.000Z</published>
    <updated>2020-07-24T06:18:36.150Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL作为一个存储系统，具有 <strong><em>buffer pool</em></strong> 机制，以避免每次查询都进行磁盘IO。</p><h3 id="缓存什么"><a href="#缓存什么" class="headerlink" title="缓存什么"></a>缓存什么</h3><p>缓存表数据与索引数据</p><h3 id="预读（read-ahead）"><a href="#预读（read-ahead）" class="headerlink" title="预读（read-ahead）"></a>预读（read-ahead）</h3><ul><li>page是InnoDB存储引擎的最小磁盘单位，一次至少读取一个page，extent是由连续的page组成的空间。</li><li>如果一个extent中被顺序读取的page超过或者等于innodb_read_ahead_threshold时，InnoDB将会异步的将下一个extent读取到buffer pool中（以linear read-ahead概述，random read-ahead在5.5后被废弃）。</li><li>预读的依据是<strong>局部性原理</strong> : CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li></ul><h3 id="淘汰算法"><a href="#淘汰算法" class="headerlink" title="淘汰算法"></a>淘汰算法</h3><p>采用改进版的LRU算法，传统的LRU算法会遇到两个问题</p><ul><li><p>预读失败<br>由于预读，提前将page放入缓冲池，但最终没有从页中读取数据。<br>改进：</p><ul><li>将LRU分为新生代（new sublist），老生代（old sublist）。</li><li>新老生代首尾相连。</li><li>新页加入缓冲池时，只加入老生代头部，如果数据被真正读取到，才会加入新生代头部，如果没有被读取，则会比新生代里的数据更早被淘汰</li></ul></li><li><p>缓冲池污染<br>当执行某个SQL时，要批量扫描大量数据（例如未命中索引，而全表扫描），导致大量热数据被淘汰。<br>改进：</p><ul><li>插入老生代头部的页，即使立刻被访问，也不会放入新生代头部。</li><li>只有满足 <strong><em>被访问</em></strong> 且 <strong><em>在老生代停留时间大于T</em></strong>，才会被放入新生代头部。</li></ul></li></ul><p><img src="/images/InnoDB/newlru.png" alt="avatar"></p><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><ul><li>innodb_buffer_pool_size<br>缓冲池的大小</li><li>innodb_old_blocks_pct<br>老生代占整个LRU链长度的比例，默认是37</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL作为一个存储系统，具有 &lt;strong&gt;&lt;em&gt;buffer pool&lt;/em&gt;&lt;/strong&gt; 机制，以避免每次查询都进行磁盘IO。&lt;/p&gt;&lt;h3 id=&quot;缓存什么&quot;&gt;&lt;a href=&quot;#缓存什么&quot; class=&quot;headerlink&quot; title=&quot;缓存什么
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（3x）</title>
    <link href="https://zhucj94.github.io/article/5533cdb0.html"/>
    <id>https://zhucj94.github.io/article/5533cdb0.html</id>
    <published>2020-05-16T08:15:16.000Z</published>
    <updated>2020-07-24T06:18:36.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="行锁策略"><a href="#行锁策略" class="headerlink" title="行锁策略"></a>行锁策略</h3><ol><li>加锁的基本单位是临键锁。（记录锁+间隙锁，左开右闭区间）</li><li>查找到数据才会加记录锁。</li><li>唯一索引上的等值查询（命中），间隙锁退化为记录锁。</li><li>辅助索引上的等值查询（命中），会在右侧相邻间隙加上间隙锁。</li><li>唯一索引上的范围查询（等值条件命中，例如&lt;=的等于命中）,会在右侧相邻间隙加上临键锁。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>// todo</p><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p><p><a href="https://blog.guitar-coder.cn/MySql%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81.html" target="_blank" rel="noopener">https://blog.guitar-coder.cn/MySql%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81.html</a></p><p><a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a></p><p><a href="https://time.geekbang.org/column/article/75659" target="_blank" rel="noopener">https://time.geekbang.org/column/article/75659</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;行锁策略&quot;&gt;&lt;a href=&quot;#行锁策略&quot; class=&quot;headerlink&quot; title=&quot;行锁策略&quot;&gt;&lt;/a&gt;行锁策略&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;加锁的基本单位是临键锁。（记录锁+间隙锁，左开右闭区间）&lt;/li&gt;&lt;li&gt;查找到数据才会加记录锁。&lt;/li&gt;&lt;li
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（3）</title>
    <link href="https://zhucj94.github.io/article/6f88bd9.html"/>
    <id>https://zhucj94.github.io/article/6f88bd9.html</id>
    <published>2020-05-14T13:56:50.000Z</published>
    <updated>2020-07-24T06:18:36.171Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks. (InnoDB执行行级锁方式是当它搜索或扫描表索引时，会在遇到的索引上加共享或排他锁，故行级锁实际上时索引记录锁)</p><h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><ul><li><p>定义<br>A record lock is a lock on an <strong>index record</strong> （记录锁锁定的是<strong>索引</strong>记录）</p></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM WHERE id &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>它会在id=1的索引记录上加锁，以阻止其他事务插入，更新，删除id=1的这一行</p></li></ul><h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><ul><li>定义<br>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.（间隙锁锁定的是<strong>索引</strong>记录间的间隔，或是第一条索引之前的范围，亦或是最后一条索引之后的范围）</li><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id BETWEEN 10 and 20 FOR UPDATE;</span><br></pre></td></tr></table></figure>会锁定（10，20），防止其他事务插入，更新，删除id在（10，20）间的记录</li></ul><p><strong>对于使用唯一索引来锁定唯一行的语句，不会产生间隙锁，而是使用记录锁。</strong> (This does not include the case that the search condition includes only some columns of a multiple-column unique index; in that case, gap locking does occur. 这句话暂时没明白)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM WHERE id &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>如果id未建立索引或具有非唯一索引，则该语句会产生间隙锁，锁定前面的间隙。</p><h3 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h3><ul><li>定义<br>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.（临键锁是锁定索引的记录锁和锁定该索引之前区间的间隙锁的组合）</li></ul><p><strong>默认情况下（RR），InnoDB使用临键锁进行搜索和索引扫描。</strong></p><p>假设索引记录为 10, 11, 13, 20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure><h3 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h3><ul><li>定义<br>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. （插入意向锁时插入行之前的插入操作设置的一种间隙锁）</li></ul><p>多个事务，在同一个索引，同一个范围区间插入记录时，<strong>如果插入的位置不冲突，不会阻塞彼此。</strong></p><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the in
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（2）</title>
    <link href="https://zhucj94.github.io/article/be44ecbc.html"/>
    <id>https://zhucj94.github.io/article/be44ecbc.html</id>
    <published>2020-05-12T13:18:18.000Z</published>
    <updated>2020-07-24T06:18:36.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共享-排他锁（Shared-and-Exclusice-Locks）"><a href="#共享-排他锁（Shared-and-Exclusice-Locks）" class="headerlink" title="共享/排他锁（Shared and Exclusice Locks）"></a>共享/排他锁（Shared and Exclusice Locks）</h3><p><strong>行级锁</strong></p><ul><li><p>定义</p><ul><li><strong>事务</strong>拿到某一行记录的共享S锁，才可以读取（当前读）这一行；</li><li><strong>事务</strong>拿到某一行记录的排他X锁，才可以修改或者删除这一行；</li></ul></li><li><p>加锁方式</p><ul><li>共享锁（S）：SELECT … LOCK IN SHARE MODE</li><li>排他锁（X）：SELECT … FOR UPDATE （<strong>update/delete/insert自动加排他锁</strong>）</li></ul></li><li><p>互斥关系</p><table><thead><tr><th align="center">-</th><th align="center">S</th><th align="center">X</th></tr></thead><tbody><tr><td align="center">S</td><td align="center">兼容</td><td align="center">互斥</td></tr><tr><td align="center">X</td><td align="center">互斥</td><td align="center">互斥</td></tr></tbody></table></li></ul><h3 id="意向锁（Intention-Locks）"><a href="#意向锁（Intention-Locks）" class="headerlink" title="意向锁（Intention Locks）"></a>意向锁（Intention Locks）</h3><p><strong>不与行级锁冲突表级锁</strong></p><ul><li><p>分类</p><ul><li>意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁。</li><li>意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁。</li></ul></li><li><p>intention locking protocol</p><ul><li>事务要获得某些<strong>行</strong>的S锁，必须先获得表的IS锁。</li><li>事务要获得某些<strong>行</strong>的X锁，必须先获得表的IX锁。</li></ul></li><li><p>互斥关系（<strong>下表的S/X锁是表级的!!!</strong>）</p></li></ul><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">互斥</td><td align="center">互斥</td><td align="center">互斥</td><td align="center">互斥</td></tr><tr><td align="center">IX</td><td align="center">互斥</td><td align="center">兼容</td><td align="center">互斥</td><td align="center">兼容</td></tr><tr><td align="center">S</td><td align="center">互斥</td><td align="center">互斥</td><td align="center">兼容</td><td align="center">兼容</td></tr><tr><td align="center">IS</td><td align="center">互斥</td><td align="center">兼容</td><td align="center">兼容</td><td align="center">兼容</td></tr></tbody></table><ul><li>判断冲突时的作用<br>无意向锁 ：<ul><li>判断表是否被其他事务加表锁。</li><li>判断表中的每一行是否被其他事务加行锁。<br>有意向锁 ：</li><li>判断表是否被其他事务加表锁。</li><li>判断表是否被其他事务加意向锁。</li></ul></li></ul><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;共享-排他锁（Shared-and-Exclusice-Locks）&quot;&gt;&lt;a href=&quot;#共享-排他锁（Shared-and-Exclusice-Locks）&quot; class=&quot;headerlink&quot; title=&quot;共享/排他锁（Shared and Exclus
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（1）自增锁（AUTO-INC Locks）</title>
    <link href="https://zhucj94.github.io/article/32458d66.html"/>
    <id>https://zhucj94.github.io/article/32458d66.html</id>
    <published>2020-05-10T13:27:21.000Z</published>
    <updated>2020-07-24T06:18:36.163Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文不介绍MySQL的读表锁（LOCK TABLE table_name READ）和写表锁（LOCK TABLE table_name WRITE</strong></p><p>自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。</p><h3 id="insert分类"><a href="#insert分类" class="headerlink" title="insert分类"></a>insert分类</h3><ul><li><p>Simple inserts<br>Statements for which the number of rows to be inserted can be determined in advance (when the statement is initially processed). This includes single-row and multiple-row INSERT and REPLACE statements that do not have a nested subquery, but not INSERT … ON DUPLICATE KEY UPDATE.</p></li><li><p>Bulk inserts<br>Statements for which the number of rows to be inserted (and the number of required auto-increment values) is not known in advance.This includes INSERT … SELECT, REPLACE … SELECT, and LOAD DATA statements, but not plain INSERT. InnoDB will assign new values for the AUTO_INCREMENT column one at a time as each row is processed.</p></li><li><p>Mixed-mode inserts<br>These are “simple insert” statements that specify the auto-increment value for some (but not all) of the new rows. An example follows, where c1 is an AUTO_INCREMENT column of table t1:</p></li></ul><p>INSERT INTO t1 (c1,c2) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’);</p><p>Another type of “mixed-mode insert” is INSERT … ON DUPLICATE KEY UPDATE, which in the worst case is in effect an INSERT followed by a UPDATE, where the allocated value for the AUTO_INCREMENT column may or may not be used during the update phase.</p><h3 id="锁模式（参数innodb-autoinc-lock-mode）"><a href="#锁模式（参数innodb-autoinc-lock-mode）" class="headerlink" title="锁模式（参数innodb_autoinc_lock_mode）"></a>锁模式（参数innodb_autoinc_lock_mode）</h3><ul><li><p>innodb_autoinc_lock_mode = 0 （traditional）</p><ul><li>此模式与innodb_autoinc_lock_mode存在前的行为相同，对于所有的‘INSERT-like’语句，都会使用特殊的AUTO-INC table-level lock，保持到语句结束。这确保了任何给定语句分配的自动增量值是连续的。</li></ul></li><li><p>innodb_autoinc_lock_mode = 1 （consecutive）</p><ul><li>默认的模式</li><li>发生Simple inserts时，在分配AUTO_INCREMENT期间，会使用轻量级的锁，获取到AUTO_INCREMENT后就释放锁，如果其他事务持有AUTO-INC table-level lock，获取轻量级锁也会等待。</li><li>发生Bulk inserts时，会使用特殊的AUTO-INC table-level lock，保持到语句结束。</li><li>发生Mixed-mode inserts时，一些行指定了AUTO_INCREMENT，将分配比要插入的行数更多的AUTO_INCREMENT，所有AUTO_INCREMENT是连续生成的，多余的丢失。</li></ul></li><li><p>innodb_autoinc_lock_mode = 2 （interleaved）</p><ul><li>对于所有的‘INSERT-like’语句不加锁</li><li>对于Bulk inserts，AUTO_INCREMENT可能不连续</li><li>binlog为SBR模式时，数据复制或恢复不安全</li></ul></li></ul><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文不介绍MySQL的读表锁（LOCK TABLE table_name READ）和写表锁（LOCK TABLE table_name WRITE&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的MVCC（Multi Versioning Concurrency Control）</title>
    <link href="https://zhucj94.github.io/article/b93dd38a.html"/>
    <id>https://zhucj94.github.io/article/b93dd38a.html</id>
    <published>2020-05-05T12:25:29.000Z</published>
    <updated>2020-07-24T06:18:36.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MVCC主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突</strong>，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。（读指快照读）</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>InnoDB is a multi-versioned storage engine: it keeps information about old versions of changed rows, to support transactional features such as concurrency and rollback.This information is stored in the tablespace in a data structure called a rollback segment（InndDB是多版本的存储引擎，它保留已更改行旧版本信息，以支持事务的并发和回滚，这些信息保存在被称为回滚段的表空间数据结构中）</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><ul><li>DB_TRX_ID：6字节，记录每一行最近一次修改它的事务ID。</li><li>DB_ROLL_PTR：7字节，记录指向回滚段UNDO LOG的指针。</li><li>DB_ROW_ID：6字节，单调递增的行ID。</li></ul><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><ul><li><p>分类</p><ul><li>insert undo log：事务在insert操作时产生的undo log，只用于事务回滚，在事务提交时立即被丢弃。</li><li>update undo log：事务在update或delete操作时产生的undo log；在事务回归时需要，<strong>在快照读时也需要</strong>，不会随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。</li></ul></li><li><p>执行流程</p><ul><li><p>假设person表有如下数据</p><table><thead><tr><th align="center">name</th><th align="center">age</th><th align="center">DB_ROW_ID</th><th align="center">DB_TRX_ID</th><th align="center">DB_ROLL_PTR</th></tr></thead><tbody><tr><td align="center">jerry</td><td align="center">24</td><td align="center">1</td><td align="center">null</td><td align="center">null</td></tr></tbody></table></li><li><p>事务1将name修改为tom</p><ul><li>事务1获取并对该行加排他锁</li><li>将行数据拷贝到undo log中</li><li>将name改为tom，并经DB_TRX_ID改为事务1的ID,回滚指针指向之前拷贝到undo log的行数据</li><li>提交事务，释放排他锁<br><img src="/images/InnoDB/update-undo-log-4-mvcc1.png" alt="avatar"></li></ul></li><li><p>事务2将age改为30</p><ul><li>事务2获取并对该行加排他锁</li><li>将行数据拷贝到undo log中，发现该行记录已有undo log，将本次的拷贝作为链表的表头。</li><li>将age改为30，并经DB_TRX_ID改为事务2的ID,回滚指针指向之前拷贝到undo log的行数据</li><li>提交事务，释放排他锁<br><img src="/images/InnoDB/update-undo-log-4-mvcc2.png" alt="avatar"></li></ul></li></ul></li></ul><p>MVCC使用的是 <strong>update undo log ，undo log实际上就是存在rollback segment中旧记录链</strong></p><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p><strong>Read View 是用来做可见性判断的</strong>，当事务执行快照读时，会生成数据库当前的一个快照，记录并维护系统当前活跃事务的ID。</p><ul><li><p>算法（简化版）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id_list : 用来维护Read View生成时系统活跃的事务ID（分配的事务ID是递增的）</span><br><span class="line">up_limit_id：id_list中最小的事务ID</span><br><span class="line">low_limit_id：ReadView生成时刻系统尚未分配的下一个事务ID，**即已出现过最大的事务ID的+1**</span><br></pre></td></tr></table></figure><ul><li>比较DB_TRX_ID与up_limit_id，如果小于，则当前事务能看到DB_TRX_ID所在的行数据，否则进入下一步。</li><li>比较DB_TRX_ID与low_limit_id，如果大于，则当前事务不能看到DB_TRX_ID所在的行数据，否则进入下一步。</li><li>判断DB_TRX_ID是否在id_list中，如果在，则当前事务不能看到DB_TRX_ID所在的行数据，否则能看到。</li></ul></li><li><p>流程<br>将当前数据的DB_TRX_ID取出，与Read View维护活跃事务ID进行比较（通过上面的算法），如果如果不符合可见性，就通过DB_ROLL_PTR取undo log中的记录，将它的DB_TRX_ID与Read View维护活跃事务ID进行比较，如果还不符合，就取链表的下一条记录，直至满足可见性，那么这个DB_TRX_ID所在的旧纪录就是当前事务能看见的记录。</p></li><li><p>RR与RC下Read View生成时机</p></li></ul><p><strong>RC隔离级别下，每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong><br>这就是RR的快照读能防止幻读，而RC不能的原因。</p><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html</a></p><p><a href="https://blog.csdn.net/SnailMann/article/details/94724197" target="_blank" rel="noopener">https://blog.csdn.net/SnailMann/article/details/94724197</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;MVCC主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突&lt;/strong&gt;，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。（读指快照读）&lt;/p&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB快照读与当前读</title>
    <link href="https://zhucj94.github.io/article/cdee20fb.html"/>
    <id>https://zhucj94.github.io/article/cdee20fb.html</id>
    <published>2020-05-04T13:51:31.000Z</published>
    <updated>2020-07-24T06:18:36.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快照读（Consistent-Nonlocking-Reads）"><a href="#快照读（Consistent-Nonlocking-Reads）" class="headerlink" title="快照读（Consistent Nonlocking Reads）"></a>快照读（Consistent Nonlocking Reads）</h3><p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time.（快照读是InnoDB使用多版本来查询某个时间点的快照）</p><p>Consistent read is the default mode in which InnoDB processes SELECT statements in READ COMMITTED and REPEATABLE READ isolation levels. A consistent read does not set any locks on the tables it accesses, and therefore other sessions are free to modify those tables at the same time a consistent read is being performed on the table.（快照读是RR和RC下处理SELECT的默认模式，快照读不在访问的表上设置任何锁，因此其他会话可以自由的修改这些表。）</p><h3 id="当前读（Locking-Reads）"><a href="#当前读（Locking-Reads）" class="headerlink" title="当前读（Locking Reads）"></a>当前读（Locking Reads）</h3><p>If you query data and then insert or update related data within the same transaction, the regular SELECT statement does not give enough protection. Other transactions can update or delete the same rows you just queried. （在同一事务中查询数据，然后更新或修改相关数据，快照读不能提供足够保护，其他事务可以修改或删除刚查询的行。）</p><p>InnoDB提供了 <strong>SELECT … LOCK IN SHARE MODE（共享锁）</strong>和 <strong>SELECT … FOR UPDATE（排他锁）</strong>提供额外的安全。</p><p>参考：<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快照读（Consistent-Nonlocking-Reads）&quot;&gt;&lt;a href=&quot;#快照读（Consistent-Nonlocking-Reads）&quot; class=&quot;headerlink&quot; title=&quot;快照读（Consistent Nonlocking Re
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://zhucj94.github.io/article/93ac284c.html"/>
    <id>https://zhucj94.github.io/article/93ac284c.html</id>
    <published>2020-05-02T12:52:14.000Z</published>
    <updated>2020-07-24T06:18:36.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性(Atomicity)<br>事务是一个原子操作，其对数据的修改，要么全执行，要么全不执行。</li><li>一致性(Consistency)<br>事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</li><li>隔离性(Isolation)<br>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性(Durability)<br>事务完成后，它对于数据的修改是永久性的，其后的其他操作或故障都不应该造成影响。</li></ul><h3 id="并发事务造成的影响"><a href="#并发事务造成的影响" class="headerlink" title="并发事务造成的影响"></a>并发事务造成的影响</h3><ul><li><p>脏读(Dirty Reads)<br>事务A读取到了事务B未提交的已修改数据，并操作了这些数据，此时事务B回滚，A依据脏数据做的操作可能不正确，不符合一致性。（例如，b=3，B事务将b改为4未提交，A事务读取到了，执行a=b+5，此时B回滚）</p></li><li><p>不可重复读(Non-Repeatable Reads)<br>事务A读取到了事务B已提交的修改数据（update，delete），不符合隔离性。</p></li><li><p>幻读(Phantom Reads)<br>事务A读取到了事务B已提交的新增数据，不符合隔离性。</p></li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><table><thead><tr><th align="center">隔离级别</th><th align="center">读数据一致性</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交(Read uncommitted)</td><td align="center">最低级别，只能保证不读取物理上损坏的数据</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">读已提交(Read committed)</td><td align="center">语句级</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读(Repeatable read)</td><td align="center">事务级</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">可序列化(Serializable)</td><td align="center">事务级</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p>注：上表只是通常情况，<strong>InnoDB Repeatable read，通过MVCC解决普通读的幻读，通过间隙锁(Gap Locks)，临键锁(Next-Key Locks)解决 *</strong>当前读<strong>* 幻影读问题</strong></p><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>MySQL默认采用自动提交模式。即如果不是显示地开始一个事务，则每个查询都被当做一个事务执行提交操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;原子性(Atomicity)&lt;br&gt;事务是一个原子操作，其对数据的修改，要么全执行，要么全不执行。&lt;/li&gt;&lt;li
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2.0</title>
    <link href="https://zhucj94.github.io/article/1b404596.html"/>
    <id>https://zhucj94.github.io/article/1b404596.html</id>
    <published>2020-04-30T08:48:37.000Z</published>
    <updated>2020-07-24T06:18:36.215Z</updated>
    
    <content type="html"><![CDATA[<p>最近又对接微信，它对外开放数据的协议就是Oauth，把阮一峰大神的几篇文章摘取几段，加深对Oauth的理解。</p><p>Oauth（Open Authorization）是一种授权机制，核心是通过颁发令牌给第三方应用，使其可以携带令牌访问数据。</p><h3 id="令牌与密码的差异"><a href="#令牌与密码的差异" class="headerlink" title="令牌与密码的差异"></a>令牌与密码的差异</h3><ul><li>令牌是短期的，<strong>到期后会失效</strong>，密码一般是长期的，用户不主动修改，不会改变。</li><li>令牌可被颁发者主动撤销，而密码一般不可由他人控制。</li><li>令牌的权限范围一般比密码小。</li></ul><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Third-party application：第三方应用程序，例如微信网站应用。</li><li>HTTP service：HTTP服务提供商，例如微信。</li><li>Resource Owner：资源所有者，例如微信用户。</li><li>User Agent：用户代理，浏览器。</li><li>Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul><h3 id="4种授权方式"><a href="#4种授权方式" class="headerlink" title="4种授权方式"></a>4种授权方式</h3><ul><li><p>授权码模式（authorization code）</p><p>最安全的一种方式，适用于有后端的web应用</p><ol><li>资源所有者访问第三方应用，后者将前者导向认证服务器。</li><li>资源所有者选择是否给予第三方应用授权。</li><li>假设资源所有者给予授权，认证服务器将资源所有者导向第三方应用事先指定的”重定向URI”，同时附上一个授权码。</li><li>第三方应用收到授权码，向认证服务器申请令牌。这一步是在第三方应用的后台的服务器上完成的，对资源所有者不可见。</li><li>认证服务器核对了授权码和重定向URI，确认无误后，向第三方应用发送访问令牌（access token）和更新令牌（refresh token）。</li></ol></li><li><p>隐藏（简化）模式（implicit）</p><p>适用于纯前端应用</p><ol><li>客户端将用户导向认证服务器。</li><li>用户决定是否给于客户端授权。</li><li>假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并带上访问令牌，token的位置是url锚点</li></ol></li><li><p>密码模式（resource owner password credentials）</p><p>适用于高度信任的应用</p><ol><li>资源拥有者向第三方应用提供用户名和密码。</li><li>第三方应用将用户名和密码发给认证服务器，向后者请求令牌。</li><li>认证服务器确认无误后，向客户端提供访问令牌。</li></ol></li><li><p>客户端模式（client credentials）</p><p>适用于没有前端的应用</p><ol><li>第三方应用向认证服务器进行身份认证，并要求一个访问令牌。</li><li>认证服务器确认无误后，直接返回访问令牌。</li></ol></li></ul><p>本文由阮一峰3篇oauth2.0文章总结而来。</p><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又对接微信，它对外开放数据的协议就是Oauth，把阮一峰大神的几篇文章摘取几段，加深对Oauth的理解。&lt;/p&gt;&lt;p&gt;Oauth（Open Authorization）是一种授权机制，核心是通过颁发令牌给第三方应用，使其可以携带令牌访问数据。&lt;/p&gt;&lt;h3 id=&quot;令牌与密码的差异&quot;&gt;&lt;a href=&quot;#令牌与密码的差异&quot; class=&quot;headerlink&quot; title=&quot;令牌与密码的差异&quot;&gt;&lt;/a&gt;令牌与密码的差异&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;令牌是短期的，&lt;strong&gt;到期后会失效&lt;/strong&gt;，密码一般是长期的，用户不主动修改，不会改变。&lt;/li&gt;&lt;li&gt;令牌可被颁发者主动撤销，而密码一般不可由他人控制。&lt;/li&gt;&lt;li&gt;令牌的权限范围一般比密码小。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Oauth2.0" scheme="https://zhucj94.github.io/tags/Oauth2-0/"/>
    
  </entry>
  
  <entry>
    <title>读写分离下数据库与缓存的一致性</title>
    <link href="https://zhucj94.github.io/article/9e1a046e.html"/>
    <id>https://zhucj94.github.io/article/9e1a046e.html</id>
    <published>2020-04-18T07:50:54.000Z</published>
    <updated>2020-07-24T06:18:36.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><ol><li>尝试从缓存get数据，结果没有命中。</li><li>从数据库获取数据，读从库。</li><li>把数据set到缓存，未来能够命中缓存。<br><img src="/images/cache/read.png" alt="avatar"></li></ol><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><ol><li>delete缓存。</li><li>操作数据库。<br><img src="/images/cache/write.png" alt="avatar"></li></ol><h3 id="为什么写操作先操作缓存，再操作数据库？"><a href="#为什么写操作先操作缓存，再操作数据库？" class="headerlink" title="为什么写操作先操作缓存，再操作数据库？"></a>为什么写操作先操作缓存，再操作数据库？</h3><ul><li>如果操作数据库成功，但是操作缓存失败，会导致数据库与缓存的不一致。</li></ul><h3 id="写操作为什么不更新缓存，而是删除？"><a href="#写操作为什么不更新缓存，而是删除？" class="headerlink" title="写操作为什么不更新缓存，而是删除？"></a>写操作为什么不更新缓存，而是删除？</h3><ul><li>使用更新，1成功，2失败，会导致缓存里是更新后的数据，数据库里是之前的数据，数据不一致。</li><li>使用删除，1成功，2失败，会导致缓存里没有数据，数据库里是之前的数据，数据没有不一致。只是下一次读取，会多一次cache miss。</li></ul><h3 id="写操作完成后，数据库主从同步未完成-主库是新数据-从库是旧数据-，此时读操作将旧数据写入缓存，怎么办？"><a href="#写操作完成后，数据库主从同步未完成-主库是新数据-从库是旧数据-，此时读操作将旧数据写入缓存，怎么办？" class="headerlink" title="写操作完成后，数据库主从同步未完成(主库是新数据,从库是旧数据)，此时读操作将旧数据写入缓存，怎么办？"></a>写操作完成后，数据库主从同步未完成(主库是新数据,从库是旧数据)，此时读操作将旧数据写入缓存，怎么办？</h3><ul><li>方案一<ul><li>通过工具（canal）订阅从库的binlog，从库执行完写操作后，再次删除缓存，淘汰可能写入缓存的旧数据。</li></ul></li><li>方案二<ul><li>写操作后，将哪个库，哪个表，哪个主键三个信息拼装一个key写到cache里，这条记录的超时时间，设置为“主从同步所需时间”。</li><li>读操作第二步改为拼装key去缓存中查找，如果命中则强制读主库，否则读从库。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; class=&quot;headerlink&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;尝试从缓存get数据，结果没有命中。&lt;/li&gt;&lt;li&gt;从数据库获取数据，读从库。&lt;/li&gt;&lt;li&gt;把数据set到缓存，未来
      
    
    </summary>
    
    
    
      <category term="缓存" scheme="https://zhucj94.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://zhucj94.github.io/article/23a3bd72.html"/>
    <id>https://zhucj94.github.io/article/23a3bd72.html</id>
    <published>2020-04-02T06:22:14.000Z</published>
    <updated>2020-07-24T06:18:36.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><ul><li>如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。</li><li>用运行时异常来表明编程错误，例如数组的下标值在0到长度-1之间，ArrayIndexOutOfBoundsException表明违反了这个前提。按照惯例，<strong><em>错误（Error）往往被JVM保留下来使用，你实现的所有非受检的 throwable 都应该是 RuntimeExceptiond 子类。</em></strong><a id="more"></a></li></ul><h3 id="避免不必要的使用受检异常"><a href="#避免不必要的使用受检异常" class="headerlink" title="避免不必要的使用受检异常"></a>避免不必要的使用受检异常</h3><ul><li>在谨慎使用的前提之下，受检异常可以提升程序的可读性；过分使用受检异常使api不方便，api必须位于try块中或者方法向上抛出异常。</li><li>可以使用下面两种方式部分替代受检异常。<ul><li>返回一个Optional，方法不抛出异常，只是返回一个空Optional，缺点是方法无法返回额外信息，而异常可以。</li><li>将受检异常变为非受检异常，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个boolean值，表明是否应该抛出异常，第二个方法正常执行，抛出非受检异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.action( args );</span><br><span class="line">&#125; <span class="keyword">catch</span> ( TheCheckedException e ) &#123;</span><br><span class="line">... <span class="comment">/* Handle exceptional condition */</span></span><br><span class="line">&#125;</span><br><span class="line">重构为下面</span><br><span class="line"><span class="keyword">if</span> ( obj.actionPermitted( args ) ) &#123;</span><br><span class="line">    obj.action( args );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">/* Handle exceptional condition */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这种重构并非总是恰当的，如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在actionPermitted和action这两个调用的时间间隔之中，对象的状态有可能会发生变化。如果单独的actionPermitted方法必须重复action方法的工作，出于性能的考虑，这种API重构就不值得去做。</li></ul></li></ul><h3 id="抛出与抽象对应的异常"><a href="#抛出与抽象对应的异常" class="headerlink" title="抛出与抽象对应的异常"></a>抛出与抽象对应的异常</h3><ul><li>如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抛出的异常时，往往会发生这种情况，为了避免这个问题，更高层的实现应该<strong><em>捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为异常转译(exception translation)</em></strong>，例如AbstractSequentialList.get(index)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><em>尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它。</em></strong>处理来自低层异常的最好做法是在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常，例如给低层传递参数之前，检查更高层方法的参数的有效性。其次的做法是，让更高层来悄悄地处理这些异常，从而将高层方法的调用者与低层的问题隔离开来，例如日志打印。</li></ul><h3 id="保证失败原子性"><a href="#保证失败原子性" class="headerlink" title="保证失败原子性"></a>保证失败原子性</h3><ul><li>一般而言，<strong><em>失败的方法调用应该使对象保持在被调用之前的状态。</em></strong>具有这种属性的方法被称为具有失败原子性 (failure atomic)。</li><li>有5中方法保持失败原子性<ul><li>使用不可变对象。</li><li>在执行操作之前检查参数的有效性，例如Arraylist.get(index)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。</li><li>在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。</li><li>编写一段恢复代码 (recoverycode)，由它来拦截操作过程中发生的失败，以及便对象回滚到操作开始之前的状态上。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对可恢复的情况使用受检异常，对编程错误使用运行时异常&quot;&gt;&lt;a href=&quot;#对可恢复的情况使用受检异常，对编程错误使用运行时异常&quot; class=&quot;headerlink&quot; title=&quot;对可恢复的情况使用受检异常，对编程错误使用运行时异常&quot;&gt;&lt;/a&gt;对可恢复的情况使用受检异常，对编程错误使用运行时异常&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。&lt;/li&gt;&lt;li&gt;用运行时异常来表明编程错误，例如数组的下标值在0到长度-1之间，ArrayIndexOutOfBoundsException表明违反了这个前提。按照惯例，&lt;strong&gt;&lt;em&gt;错误（Error）往往被JVM保留下来使用，你实现的所有非受检的 throwable 都应该是 RuntimeExceptiond 子类。&lt;/em&gt;&lt;/strong&gt;
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="https://zhucj94.github.io/article/ad01bc3e.html"/>
    <id>https://zhucj94.github.io/article/ad01bc3e.html</id>
    <published>2020-03-30T11:09:10.000Z</published>
    <updated>2020-07-24T06:18:36.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检查参数有效性"><a href="#检查参数有效性" class="headerlink" title="检查参数有效性"></a>检查参数有效性</h3><ul><li>大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。例如，索引值必须是非负数。<strong><em>在方法的开头检查参数，抛出适当的异常快速且清楚的结束方法</em></strong>。如果不检查参数，可能会出现令人困惑的异常，或者方法正常返回，但计算错误。</li><li>可以使用guava的Preconditions检查参数。<a id="more"></a></li></ul><h3 id="必要时进行防御性拷贝"><a href="#必要时进行防御性拷贝" class="headerlink" title="必要时进行防御性拷贝"></a>必要时进行防御性拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                start + <span class="string">" after "</span> + end);</span><br><span class="line">                <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>假定类的客户端尽力摧毁类不变量，防御性地编写程序。</em></strong>Period看起来是不可变的，但是利用Date的可变性，就能打破不变性。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Period(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date()).end().setYear(<span class="number">78</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="keyword">this</span>.start + <span class="string">" after "</span> + <span class="keyword">this</span>.end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新的构造方法和新的访问器，Period是真正不可变的。在可能的情况下，应该使用不可变对象作为对象的组件，如Period中使用LocalDateTime，就不用做防御性拷贝。<br><strong><em>防御性拷贝是在检查参数的有效性之前进行的</em></strong>，有效性检查是在拷贝上而不是在原始实例上进行的,这样检查参数和拷贝参数之间的漏洞窗口期间保护类不受其他线程对参数的更改的影响，这称为time-of-check/time-of-use 或 TOCTOU 攻击。</p><ul><li>如果拷贝的成本太高，并且类信任它的客户端不会不适当地修改组件，则可以用文档替换防御性拷贝，该文档概述了客户端不得修改受影响组件。</li></ul><h3 id="仔细设计方法签名"><a href="#仔细设计方法签名" class="headerlink" title="仔细设计方法签名"></a>仔细设计方法签名</h3><ul><li>仔细选择方法名，选择与同一包中的其他名称一致且易于理解的名称，避免使用较长的方法名，可以参考 Java 类库API</li><li>不要过分地提供方便的方法，太多的方法使得类难以使用和维护，对于类或接口支持的每个操作，<br>提供一个功能完整的方法。</li><li>避免过长的参数列表，尽量是4个及以下的参数，过多的参数会使方法难以使用。有3种技术可以缩短列表<ul><li>创建辅助类保存参数组，这些辅助类通常是静态内部类。</li><li>将方法分解为多个方法，每个方法只需要参数的一个子集。例如List没有提供子列表中元素的第一个或最后一个索引位置，但是可以结合subList，indexOf，lastIndexOf使用。</li><li>Builder模式，定义一个对象来表示所有的参数，并允许客户端在这个对象上进行多个”setter” 调用，设置好所需的参数后，客户端调用对象的”execute”方法，该方法对参数进行最后的有效性检查，并执行实际的计算。</li></ul></li><li>与布尔型参数相比，优先使用两个元素枚举类型，除非布尔型参数的含义在方法名中是明确的。</li></ul><h3 id="明智审慎地使用重载"><a href="#明智审慎地使用重载" class="headerlink" title="明智审慎地使用重载"></a>明智审慎地使用重载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">                 <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">                 <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">                 <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">             System.out.println(classify(c));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>这个main方法将输出三次Unknown Collection，因为classify方法被重载了，<strong><em>在编译时选择要调用哪个重载方法。</em></strong></li><li>重载（overloaded）方法之间的选择是静态的，<strong><em>而重写（overridden）方法之间的选择是动态的。重写总是会执行“最具体 (most specific)”的重写方法。</em></strong></li><li><strong><em>一个安全和保守的策略是永远不要导出两个具有相同参数数量的重载，可以为方法赋予不同的名称，而不是重载它们。</em></strong>例如ObjectOutputStream的writeBoolean(boolean)，writeFloat(float)。</li><li>类的多个构造函数总是被重载，可以使用静态工厂方法而不是构造。</li><li>不要在相同参数位置重载采用不同函数式接口的方法。例如Executors.submit(Callable),Executors.submit(Runnable)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool().submit(System.out::println)<span class="comment">//无法编译Ambiguous method</span></span><br></pre></td></tr></table></figure>Runnable.run()返回是void，println返回是void，看起来应该能编译，但并不能。</li></ul><h3 id="明智审慎地使用可变参数"><a href="#明智审慎地使用可变参数" class="headerlink" title="明智审慎地使用可变参数"></a>明智审慎地使用可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg : args)</span><br><span class="line">        sum += arg;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在需要参数数量可变的方法时，可变参数是有效的,在性能关键的情况下使用可变参数时要小心。每次调用可变参数方法都会导致数组分配和初始化。假设你已确定95％的调用是三个或更少的参数的方法，那么声明该方法的五个重载。例如guava的ImmutableMap静态工厂方法of。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3)</span><span class="params">( &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; ImmutableMap&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="返回空的数组或集合，不要返回-null"><a href="#返回空的数组或集合，不要返回-null" class="headerlink" title="返回空的数组或集合，不要返回 null"></a>返回空的数组或集合，不要返回 null</h3><ul><li>在几乎每次使用返回 null 来代替空集合或数组的方法时，都需要判断非空。</li><li>如果有证据表明分配空集合会损害性能，可以通过重复返回相同的不可变空集合来避免分配，例如Collections.emptyList。</li></ul><h3 id="明智审慎地返回-Optional"><a href="#明智审慎地返回-Optional" class="headerlink" title="明智审慎地返回 Optional"></a>明智审慎地返回 Optional</h3><ul><li>在 Java 8 中加入了 Optional&lt;T&gt;，返回Optional的方法比抛出异常的方法更灵活、更容易使用，而且比返回 null 的方法更不容易出错。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>)</span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String lastWordInLexicon = max(words).orElse(<span class="string">"No words..."</span>);</span><br></pre></td></tr></table></figure>Optional很简单,Optional.empty() 返回一个空的 Optional， Optional.of(value)返回一个包含给定非null值的Optional，不要将null传入of方法，这将会抛出NullPointerException。</li></ul><p><strong><em>永远不要通过返回 Optional 的方法返回一个null</em></strong>，这违反了Optional设计初衷。<br>Optional迫使用户面对可能没有返回值的事实，抛出未抛出未检查的异常或返回null允许用户忽略这种可能性，从而带来潜在的错误。抛出一个检查异常需要在客户端中添加额外的代码。</p><ul><li>容器类型，包括集合、映射、Stream、数组和Optional，不应该封装在Optional中，与其返回一个空的 Optional&lt;List<t>&gt; ，不还如返回一个空的 List<t>。</t></t></li><li>通常，<strong><em>如果可能无法返回结果，并且在没有返回结果，客户端还必须执行特殊处理的情况下，则应声明返回 Optional 的方法。</em></strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;检查参数有效性&quot;&gt;&lt;a href=&quot;#检查参数有效性&quot; class=&quot;headerlink&quot; title=&quot;检查参数有效性&quot;&gt;&lt;/a&gt;检查参数有效性&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。例如，索引值必须是非负数。&lt;strong&gt;&lt;em&gt;在方法的开头检查参数，抛出适当的异常快速且清楚的结束方法&lt;/em&gt;&lt;/strong&gt;。如果不检查参数，可能会出现令人困惑的异常，或者方法正常返回，但计算错误。&lt;/li&gt;&lt;li&gt;可以使用guava的Preconditions检查参数。
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Lambdas和Streams</title>
    <link href="https://zhucj94.github.io/article/33749838.html"/>
    <id>https://zhucj94.github.io/article/33749838.html</id>
    <published>2020-03-28T09:40:14.000Z</published>
    <updated>2020-07-24T06:18:36.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优先使用标准的函数式接口"><a href="#优先使用标准的函数式接口" class="headerlink" title="优先使用标准的函数式接口"></a>优先使用标准的函数式接口</h3><ul><li>有了lambda后，编写 API 的最佳实践已经发生了很大的变化，例如模板方法模式，其中一个子类重写原始方法以专门化其父类的行为，变得没有那么吸引人。现代替代的选择是提供一个静态工厂或构造方法来接受函数对象以达到相同的效果。<br>例如 LinkedHashMap，可以通过重写removeEldestEntry 方法将此类用作缓存，每次将新的key 值加入到 map时都会调用该方法，当此方法返回true时，map将删除传递给该方法的最久条目。<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果LinkedHashMap是现在编写，可以用lambda来实现，增加一个构造或静态工厂方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BiPredicate&lt;Map&lt;K,V&gt;, Map.Entry&lt;K,V&gt;&gt; removeEldestEntry;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(BiPredicate&lt;Map&lt;K,V&gt;, Map.Entry&lt;K,V&gt;&gt; param)</span> </span>&#123;</span><br><span class="line">    removeEldestEntry = param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>java.util.Function中有43个几口，但是只有6个基本接口，其余的均是其派生接口</li></ul><table><thead><tr><th align="center">接口</th><th align="center">方法</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">UnaryOperator&lt;T&gt;</td><td align="center">T apply(T t)</td><td align="center">String::toLowerCase</td></tr><tr><td align="center">BinaryOperator&lt;T&gt;</td><td align="center">T apply(T t1, T t2)</td><td align="center">BigInteger::add</td></tr><tr><td align="center">Predicate&lt;T&gt;</td><td align="center">boolean test(T t)</td><td align="center">Collection::isEmpty</td></tr><tr><td align="center">Function&lt;T,R&gt;</td><td align="center">R apply(T t)</td><td align="center">Arrays::asList</td></tr><tr><td align="center">Supplier&lt;T&gt;</td><td align="center">T get()</td><td align="center">Instant::now</td></tr><tr><td align="center">Consumer&lt;T&gt;</td><td align="center">void accept(T t)</td><td align="center">System.out::println</td></tr></tbody></table><ul><li>始终使用 @FunctionalInterface 注解标注你的函数式接口。<br>它告诉读者该接口是为了实现lambda表达式而设计的。<br>它使接口可靠，因为除非只有一个抽象方法，否则接口不会编译。<br>它可以防止维护人员在接口发生变化时不小心地将抽象方法添加到接口中。</li></ul><p>// TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;优先使用标准的函数式接口&quot;&gt;&lt;a href=&quot;#优先使用标准的函数式接口&quot; class=&quot;headerlink&quot; title=&quot;优先使用标准的函数式接口&quot;&gt;&lt;/a&gt;优先使用标准的函数式接口&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;有了lambda后，编写 API 的最佳实践已经发生了很大的变化，例如模板方法模式，其中一个子类重写原始方法以专门化其父类的行为，变得没有那么吸引人。现代替代的选择是提供一个静态工厂或构造方法来接受函数对象以达到相同的效果。&lt;br&gt;例如 LinkedHashMap，可以通过重写removeEldestEntry 方法将此类用作缓存，每次将新的key 值加入到 map时都会调用该方法，当此方法返回true时，map将删除传递给该方法的最久条目。
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>枚举</title>
    <link href="https://zhucj94.github.io/article/633a03ca.html"/>
    <id>https://zhucj94.github.io/article/633a03ca.html</id>
    <published>2020-03-25T08:41:57.000Z</published>
    <updated>2020-07-24T06:18:36.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用枚举类型替代整型常量"><a href="#使用枚举类型替代整型常量" class="headerlink" title="使用枚举类型替代整型常量"></a>使用枚举类型替代整型常量</h3><ul><li>在枚举类型添加到java之前，表示枚举的常见模式是一组名为int的常量，每个类型的成员都有一个常量，没有简单的方法将 int 枚举常量转换为可打印的字符串。如果你打印这样一个常量或者从调试器中显示出来，你看到的只是一个数字。 没有可靠的方法来迭代组中的所有 int 枚举常量，甚至无法获得int 枚举组的大小(String枚举亦然)。<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_GRANNY_SMITH = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li>enum是java.lang.Enum的子类，它实现了Comparable和Serializable，并提供了valueof(),values()等方法便于使用。</li><li>要将数据与枚举常量相关联，需声明实例属性并编写一个构造方法，<strong>构造方法带有数据并将数据保存在属性中；由于枚举不变的，所以所有的属性都应该是final的；最好将属性私有化并提供公共访问方法。</strong></li><li>在枚举类型中声明一个抽象的方法，并用常量特定的类主体中的每个常量的具体方法重写它。这种方法被称为特定于常量（constant-specific）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol) &#123; </span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSymbol</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> symbol; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用实例属性替代序数"><a href="#使用实例属性替代序数" class="headerlink" title="使用实例属性替代序数"></a>使用实例属性替代序数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,</span><br><span class="line">    SEXTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ordinal() + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有枚举都有一个 ordinal 方法，它返回每个枚举常量类型的数值位置，上面的枚举能正常工作，但对于维护来说则是一场噩梦。如果常量被重新排序，调用者将受到影响。</li><li><strong>永远不要从枚举的序号中得出与它相关的值; 请将其保存在实例属性中。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>),</span><br><span class="line">    SEXTET(<span class="number">6</span>), SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>),</span><br><span class="line">    NONET(<span class="number">9</span>), DECTET(<span class="number">10</span>), TRIPLE_QUARTET(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.numberOfMusicians = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberOfMusicians;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用枚举类型替代整型常量&quot;&gt;&lt;a href=&quot;#使用枚举类型替代整型常量&quot; class=&quot;headerlink&quot; title=&quot;使用枚举类型替代整型常量&quot;&gt;&lt;/a&gt;使用枚举类型替代整型常量&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;在枚举类型添加到java之前，表示枚举的常见模式是一组名为int的常量，每个类型的成员都有一个常量，没有简单的方法将 int 枚举常量转换为可打印的字符串。如果你打印这样一个常量或者从调试器中显示出来，你看到的只是一个数字。 没有可靠的方法来迭代组中的所有 int 枚举常量，甚至无法获得int 枚举组的大小(String枚举亦然)。
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="https://zhucj94.github.io/article/7678a22a.html"/>
    <id>https://zhucj94.github.io/article/7678a22a.html</id>
    <published>2020-03-19T05:42:15.000Z</published>
    <updated>2020-07-24T06:18:36.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不要使用原始类型"><a href="#不要使用原始类型" class="headerlink" title="不要使用原始类型"></a>不要使用原始类型</h3><ul><li>一个类或接口，它的声明有一个或多个类型参数（type parameters ），统称为泛型类型（generic types）。没有任何类型参数的泛型类型称为原始类型（List是List &lt;T&gt;的原始类型）。它们的存在主要是为了与没有泛型之前的代码相兼容。</li><li>使用原始类型是合法的，但如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List stamps = ... ; <span class="comment">//警告</span></span><br><span class="line">stamps.add(<span class="keyword">new</span> Coin());<span class="comment">// 如果有泛型，此处无法编译</span></span><br><span class="line">(Stamp)stamps.get(<span class="number">0</span>);<span class="comment">//编译通过，运行ClassCastException</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="列表优于数组"><a href="#列表优于数组" class="headerlink" title="列表优于数组"></a>列表优于数组</h3><p>1.1. 数组是协变的(covariant)，<strong>即如果Child是Super的子类型，那么Child[]亦是Super[]的子类型。</strong><br>1.2. 泛型是不变的(invariant)，<strong>对于任意两种不同的类型Type1，Type2，List<type1>既不是List<type>的子类型也不是父类型。</type></type1></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行时会抛出ArrayStoreException</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>;</span><br><span class="line"><span class="comment">//无法编译</span></span><br><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.1. 数组被<strong>具体化了（reified）</strong>，数组在运行时知道并强制执行它们的元素类型。如上所示，若将String放入Long数组，会抛出ArrayStoreException<br>2.2. 泛型通过<strong>擦除（erasure）</strong>来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 擦除是允许泛型类型与不使用泛型的遗留代码自由互操作，从而确保在 Java 5 中平滑过渡到泛型。<br>3.1. 由于这些基本差异数组和泛型不能很好地在一起混合使用，new List<e>[] ， new<br>List<string>[] ， new E[] 都是不合法的。<br>3.2. 当将数组和列表混合使用，如将列表强制转换为数组类型时，得到泛型数组创建错误，或是未经检查的强制转换警告时，<strong>使用集合会获得更好的类型安全性和互操作性</strong>。</string></e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] choiceArray;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt;  choices)</span> </span>&#123;</span><br><span class="line">        choiceArray = (T[])choices.toArray();  <span class="comment">//警告Unchecked cast:'java.lang.Object[]' to 'E[]'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chooser</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; choiceArray;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chooser</span><span class="params">(Collection&lt;T&gt;  choices)</span> </span>&#123;</span><br><span class="line">        choiceArray = <span class="keyword">new</span> Arraylist&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先使用泛型方法"><a href="#优先使用泛型方法" class="headerlink" title="优先使用泛型方法"></a>优先使用泛型方法</h3><ul><li>对于简单的泛型方法来说，<strong>此方法编译不会生成警告，并提供类型安全性和易用性</strong>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无泛型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">union</span><span class="params">(Set s1, Set s2)</span> </span>&#123;</span><br><span class="line">    Set result = <span class="keyword">new</span> HashSet(s1);<span class="comment">//编译警告</span></span><br><span class="line">    result.addAll(s2);<span class="comment">//编译警告</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>有时，需要创建一个不可改变但适用于许多不同类型的对象。因为泛型是通过擦除来实现的，所以可以使用单个对象进行所有必需的类型参数化，但是需要编写一个静态工厂方法来重复地为每个请求的类型参数化分配对象。 这种称为泛型单例工厂（generic singleton factory）的模式用于方法对象（ function objects），例如Collections.emptySet<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set EMPTY_SET = <span class="keyword">new</span> EmptySet&lt;&gt;();</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">emptySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Set&lt;T&gt;) EMPTY_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用限定通配符来增加API的灵活性"><a href="#使用限定通配符来增加API的灵活性" class="headerlink" title="使用限定通配符来增加API的灵活性"></a>使用限定通配符来增加API的灵活性</h3><ul><li>为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型。即PECS： producer-extends，consumer-super<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; p)</span></span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Comparable和Comparator实例总是消费者，通常使用Comparable&lt;? super T&gt;，Comparator&lt;? super T&gt; 优于 Comparable<t>，Comparator<t><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></t></t></li><li>如果类型参数在方法声明中只出现一次，将其替换为通配符。如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。<br>swap 方法的客户端不需要面对更复杂的声明。辅助方法（swapHelper）具有我们认为对公共方法来说过于复杂的签名<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//list.set(i, list.set(j, list.get(i))); 无法编译，因为无法确定类型</span></span><br><span class="line">    swapHelper(list, i, j);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h3><ul><li>泛型 API 的通常用法（以集合 API 为例）限制了每个容器的固定数量的类型参数，可以通过<strong>将类型参数放在键上而不是容器上来解决此限制</strong>，可以使用 Class 对象作为此类型安全异构容器的键。 以这种方式使用的Class 对象称为<strong>类型令牌</strong>。 也可以使用自定义键类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">         favorites.put(Objects.requireNonNull(type), instance);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span>&lt;T&gt; T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>Favorites 实例是类型安全的：当请求一个字符串时它永远不会返回一个整数。 它也是异构的：与普通Map 不同，所有的键都是不同的类型。 因此，我们将 Favorites 称为类型安全异构容器（typesafe heterogeneous container）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不要使用原始类型&quot;&gt;&lt;a href=&quot;#不要使用原始类型&quot; class=&quot;headerlink&quot; title=&quot;不要使用原始类型&quot;&gt;&lt;/a&gt;不要使用原始类型&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;一个类或接口，它的声明有一个或多个类型参数（type parameters ），统称为泛型类型（generic types）。没有任何类型参数的泛型类型称为原始类型（List是List &amp;lt;T&amp;gt;的原始类型）。它们的存在主要是为了与没有泛型之前的代码相兼容。&lt;/li&gt;&lt;li&gt;使用原始类型是合法的，但如果你使用原始类型，则会丧失泛型的所有安全性和表达上的优势&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; List stamps = ... ; &lt;span class=&quot;comment&quot;&gt;//警告&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stamps.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Coin());&lt;span class=&quot;comment&quot;&gt;// 如果有泛型，此处无法编译&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(Stamp)stamps.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//编译通过，运行ClassCastException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;列表优于数组&quot;&gt;&lt;a href=&quot;#列表优于数组&quot; class=&quot;headerlink&quot; title=&quot;列表优于数组&quot;&gt;&lt;/a&gt;列表优于数组&lt;/h3&gt;&lt;p&gt;1.1. 数组是协变的(covariant)，&lt;strong&gt;即如果Child是Super的子类型，那么Child[]亦是Super[]的子类型。&lt;/strong&gt;&lt;br&gt;1.2. 泛型是不变的(invariant)，&lt;strong&gt;对于任意两种不同的类型Type1，Type2，List&lt;type1&gt;既不是List&lt;type&gt;的子类型也不是父类型。&lt;/type&gt;&lt;/type1&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//运行时会抛出ArrayStoreException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object[] objectArray = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Long[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectArray[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&quot;I don&#39;t fit in&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//无法编译&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Object&amp;gt; ol = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Long&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>创建对象-effective java</title>
    <link href="https://zhucj94.github.io/article/bff37142.html"/>
    <id>https://zhucj94.github.io/article/bff37142.html</id>
    <published>2020-02-23T06:00:53.000Z</published>
    <updated>2020-07-24T06:18:36.234Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用静态工厂方法替代构造"><a href="#使用静态工厂方法替代构造" class="headerlink" title="使用静态工厂方法替代构造"></a>使用静态工厂方法替代构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态工厂方法是有名字的，在类中需要具有<strong>相同签名(方法的名称和参数类型)</strong>的多个构造方法时，用静态工厂方法替换构造，并仔细选择名字来突出它们差异。</li><li>静态工厂方法不需要每次调用时都创建一个对象，这是享元模式（Flyweight）的基础，如果经常请求等价对象，那么将极大的提高性能。</li><li>静态工厂方法可以返回其返回类型的子类型对象。<a id="more"></a><h3 id="当构造方法参数过多时使用builder模式"><a href="#当构造方法参数过多时使用builder模式" class="headerlink" title="当构造方法参数过多时使用builder模式"></a>当构造方法参数过多时使用builder模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用私有构造方法执行非实例化"><a href="#使用私有构造方法执行非实例化" class="headerlink" title="使用私有构造方法执行非实例化"></a>使用私有构造方法执行非实例化</h3><ul><li>实用类（utility classes）（例如Collections）不是设计用来被实例化的：一个实例是没有意义的。</li><li>在没有显式构造方法的情况下，编译器提供了一个公共的、无参的默认构造方法，可以通过包含一个私有构造方法来实现类的非实例化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用依赖注入取代硬链接资源"><a href="#使用依赖注入取代硬链接资源" class="headerlink" title="使用依赖注入取代硬链接资源"></a>使用依赖注入取代硬链接资源</h3><ul><li>许多类依赖一个或多个底层资源。例如有一个拼写检查类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">错误的,每种语言都有自己的字典，特殊的字典被用于特殊的词汇表</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private static final Lexicon dictionary &#x3D; ...;</span><br><span class="line">    private SpellChecker() &#123;&#125; &#x2F;&#x2F; Noninstantiable</span><br><span class="line">    public static boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现这一需求的简单模式是在创建新实例时将资源传递到构造方法中，这是</span><br><span class="line">依赖项注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器</span><br><span class="line">中</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary;</span><br><span class="line">    public SpellChecker(Lexicon dictionary) &#123;</span><br><span class="line">        this.dictionary &#x3D; Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125; </span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="避免创建不必要对象"><a href="#避免创建不必要对象" class="headerlink" title="避免创建不必要对象"></a>避免创建不必要对象</h3><ul><li>在需要时重用一个对象而不是创建一个新的相同功能对象通常是恰当的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String.matches每次都会创建一个Pattren对象,创建Pattern实例是昂贵的，因为它需要将正则表达式编译成有限状态机</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span></span><br><span class="line">    * <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line">&#125;</span><br><span class="line">将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(<span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量 sum 被声明成了Long 而不是 <span class="keyword">long</span> ，这意味着程序构造了大量不必要的 Long 实例</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>除非池中的对象<strong>非常重量级</strong>，否则通过维护自己的对象池来避免对象创建是一个坏主意,现代JVM 实现具有高度优化的垃圾收集器，它们在轻量级对象上轻松胜过此类对象池。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用静态工厂方法替代构造&quot;&gt;&lt;a href=&quot;#使用静态工厂方法替代构造&quot; class=&quot;headerlink&quot; title=&quot;使用静态工厂方法替代构造&quot;&gt;&lt;/a&gt;使用静态工厂方法替代构造&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Boolean &lt;span class=&quot;title&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b ? Boolean.TRUE : Boolean.FALSE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;静态工厂方法是有名字的，在类中需要具有&lt;strong&gt;相同签名(方法的名称和参数类型)&lt;/strong&gt;的多个构造方法时，用静态工厂方法替换构造，并仔细选择名字来突出它们差异。&lt;/li&gt;&lt;li&gt;静态工厂方法不需要每次调用时都创建一个对象，这是享元模式（Flyweight）的基础，如果经常请求等价对象，那么将极大的提高性能。&lt;/li&gt;&lt;li&gt;静态工厂方法可以返回其返回类型的子类型对象。
    
    </summary>
    
    
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
