<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小朱的blog</title>
  
  <subtitle>及时当勉励，岁月不待人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhucj94.github.io/"/>
  <updated>2020-08-04T09:18:33.072Z</updated>
  <id>https://zhucj94.github.io/</id>
  
  <author>
    <name>飞光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis源码之Executor</title>
    <link href="https://zhucj94.github.io/article/f8953bf7.html"/>
    <id>https://zhucj94.github.io/article/f8953bf7.html</id>
    <published>2020-08-02T10:01:17.000Z</published>
    <updated>2020-08-04T09:18:33.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。</p><hr><h3 id="Executor及其子类">Executor及其子类</h3><p><img src="/images/mybatis/executor.png" alt="avatar"></p><a id="more"></a><p><img src="/images/mybatis/executor_model.png" alt="avatar"></p><h4 id="Executor">Executor</h4><p>所有执行器的父类，定义了提交，回归，查询（DQL），修改(不只是update，是所有DML)，获取事务等方法。</p><h4 id="BaseExecutor">BaseExecutor</h4><p>BaseExecutor采用<strong>模板方法模式</strong>，实现大多数共用的功能，只将如下方法交给子类实现。一级缓存核心代码就位于BaseExecutor中（关于一级缓存，请看 <a href="https://zhucj94.github.io/article/7dd9b5ec.html">https://zhucj94.github.io/article/7dd9b5ec.html</a> ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>以query为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 从一级缓存获取</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//未获取到查询数据库</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="comment">//设置缓存占位符，不明白含义</span></span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//交给子类  </span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExecutor">SimpleExecutor</h4><p>默认的Executor，Configuration.newExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  <span class="comment">// 未指定executorType时，默认simple</span></span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleExecutor的逻辑很简单，获取StatementHandler，每次都创建Statement，将数据交给StatementHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     Configuration configuration = ms.getConfiguration();</span><br><span class="line">     <span class="comment">//获取StatementHandler</span></span><br><span class="line">     StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">     stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">     <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     closeStatement(stmt);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   Statement stmt;</span><br><span class="line">   Connection connection = getConnection(statementLog);</span><br><span class="line">   <span class="comment">// 创建Statement</span></span><br><span class="line">   stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">   handler.parameterize(stmt);</span><br><span class="line">   <span class="keyword">return</span> stmt;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h4 id="ReuseExecutor">ReuseExecutor</h4><p>ReuseExecutor与Simple的不同在于，当sql语句相同时，，<strong>ReuseExecutor会重用Statement</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Statement&gt; statementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="comment">// 如果statementMap中有相同的Statement，就复用</span></span><br><span class="line">    <span class="keyword">if</span> (hasStatementFor(sql)) &#123;</span><br><span class="line">      stmt = getStatement(sql);</span><br><span class="line">      applyTransactionTimeout(stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则就新建，并且置入map</span></span><br><span class="line">      Connection connection = getConnection(statementLog);</span><br><span class="line">      stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">      putStatement(sql, stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasStatementFor</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Statement statement = statementMap.get(sql);</span><br><span class="line">      <span class="keyword">return</span> statement != <span class="keyword">null</span> &amp;&amp; !statement.getConnection().isClosed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Statement <span class="title">getStatement</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementMap.get(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putStatement</span><span class="params">(String sql, Statement stmt)</span> </span>&#123;</span><br><span class="line">    statementMap.put(sql, stmt);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="BatchExecutor">BatchExecutor</h4><p>BatchExecutor同样会重用Statment，且会批量提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UPDATE_RETURN_VALUE = Integer.MIN_VALUE + <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> String currentSql;</span><br><span class="line"><span class="keyword">private</span> MappedStatement currentStatement;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BatchExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(configuration, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">  <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">  <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">  <span class="keyword">final</span> Statement stmt;</span><br><span class="line">  <span class="comment">// 如果sql与currentSql相同，MappedStatement与currentStatement相同，就获取batchResultList的最后一个元素，并将参数加入</span></span><br><span class="line">  <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) &#123;</span><br><span class="line">    <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">    stmt = statementList.get(last);</span><br><span class="line">    applyTransactionTimeout(stmt);</span><br><span class="line">    handler.parameterize(stmt);<span class="comment">// fix Issues 322</span></span><br><span class="line">    BatchResult batchResult = batchResultList.get(last);</span><br><span class="line">    batchResult.addParameterObject(parameterObject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不相同，就新建BatchResult和Statement，并将其add到list，且设置currentSql和currentStatement为当前值</span></span><br><span class="line">    Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    handler.parameterize(stmt);    <span class="comment">// fix Issues 322</span></span><br><span class="line">    currentSql = sql;</span><br><span class="line">    currentStatement = ms;</span><br><span class="line">    statementList.add(stmt);</span><br><span class="line">    batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过上面两个操作，就形成了两个list下标一一对应的且部分复用的情况（间隔调用相同方法，不会复用Statement）。</span></span><br><span class="line"></span><br><span class="line">  handler.batch(stmt);</span><br><span class="line">  <span class="comment">//统一返回-2147482646，此时还没有批量提交，无法得知操作行数，统一返回一个负数</span></span><br><span class="line">  <span class="comment">//所以当executor为batch时，insert，delete，update方法，不能使用返回值&gt;0判断方法是否成功。</span></span><br><span class="line">  <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = statementList.size(); i &lt; n; i++) &#123;</span><br><span class="line">      Statement stmt = statementList.get(i);</span><br><span class="line">      applyTransactionTimeout(stmt);</span><br><span class="line">      BatchResult batchResult = batchResultList.get(i);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//循环提交  </span></span><br><span class="line">        batchResult.setUpdateCounts(stmt.executeBatch());</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CachingExecutor">CachingExecutor</h4><p>CachingExecutor使用装饰模式，增强上述的Executor，二级缓存的调用逻辑也位于CachingExecutor中，关于二级缓存请看（ <a href="https://zhucj94.github.io/article/3f89eca3.html">https://zhucj94.github.io/article/3f89eca3.html</a> ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被装饰的Executor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CachingExecutor</span><span class="params">(Executor delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    delegate.setExecutorWrapper(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">// 将update逻辑叫给被装饰的Executor</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本文执行器图片转自<br><a href="https://blog.csdn.net/landywu1985/article/details/106736621" target="_blank" rel="noopener">https://blog.csdn.net/landywu1985/article/details/106736621</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。&lt;/p&gt;&lt;hr&gt;&lt;h3 id=&quot;Executor及其子类&quot;&gt;Executor及其子类&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/mybatis/executor.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://zhucj94.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>blog安装的插件</title>
    <link href="https://zhucj94.github.io/article/9fc0ebd4.html"/>
    <id>https://zhucj94.github.io/article/9fc0ebd4.html</id>
    <published>2020-08-02T08:53:50.000Z</published>
    <updated>2020-08-02T11:45:17.953Z</updated>
    
    <content type="html"><![CDATA[<p>blog 安装的Node.js插件越来越多，记录下 😁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-git-backup --save  //备份插件</span><br><span class="line">cnpm install hexo-neat --save  //静态资源压缩插件</span><br><span class="line">cnpm install hexo-abbrlink --save  //url格式化插件</span><br><span class="line">cnpm install hexo-wordcount --save  //文字统计插件</span><br><span class="line">cnpm install hexo-generator-feed //rss</span><br><span class="line">--- 替换渲染引擎</span><br><span class="line">cnpm un hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-markdown-it --save</span><br><span class="line">cnpm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;blog 安装的Node.js插件越来越多，记录下 😁&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
    
      <category term="blog搭建" scheme="https://zhucj94.github.io/tags/blog%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码之二级缓存</title>
    <link href="https://zhucj94.github.io/article/3f89eca3.html"/>
    <id>https://zhucj94.github.io/article/3f89eca3.html</id>
    <published>2020-07-26T06:51:37.000Z</published>
    <updated>2020-08-02T11:35:22.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。</p><hr><p>MyBatis二级缓存的调用逻辑位于<strong>CachingExecutor</strong>中</p><h3 id="Cache及其子类">Cache及其子类</h3><p>Mybatis使用Cache及子类来囊括所有缓存实现<br>所有子类如下图（idea查看 类右键 -&gt; Diagrams -&gt; show Diagrams -&gt; ctrl+alt+b选择所有子类）<br><img src="/images/mybatis/cache_child.png" alt="avatar"></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The identifier of this cache</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> The number of elements stored in the cache (not its capacity).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些子类中有4个类为缓存淘汰策略</p><ol><li>SoftCache（软引用，在系统要发生内存溢出的异常之前,将会把这些对象列进回收范围之中进行第二次回收）</li><li>LruCache</li><li>FifoCache</li><li>WeakCache（弱引用，只能生存到下一次垃圾收集发生之前）</li></ol><h4 id="SoftCache">SoftCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="comment">//强引用双端队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;Object&gt; hardLinksToAvoidGarbageCollection;</span><br><span class="line">  <span class="comment">//弱引用队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queueOfGarbageCollectedEntries;</span><br><span class="line">  <span class="comment">//被装饰Cache</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numberOfHardLinks;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除所有未加入强引用队列的软引用</span></span><br><span class="line">    removeGarbageCollectedItems();</span><br><span class="line">    delegate.putObject(key, <span class="keyword">new</span> SoftEntry(key, value, queueOfGarbageCollectedEntries));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="comment">// assumed delegate cache is totally managed by this cache</span></span><br><span class="line">    <span class="comment">// 从被修饰的Cache中获取值</span></span><br><span class="line">    SoftReference&lt;Object&gt; softReference = (SoftReference&lt;Object&gt;) delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (softReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = softReference.get();</span><br><span class="line">      <span class="comment">//如果被回收，移除被修饰Cache的键值</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        delegate.removeObject(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没被回收，将弱引升级为强引用，避免被回收，供下次命中使用</span></span><br><span class="line">        <span class="comment">// See #586 (and #335) modifications need more than a read lock</span></span><br><span class="line">        <span class="keyword">synchronized</span> (hardLinksToAvoidGarbageCollection) &#123;</span><br><span class="line">          hardLinksToAvoidGarbageCollection.addFirst(result);</span><br><span class="line">          <span class="keyword">if</span> (hardLinksToAvoidGarbageCollection.size() &gt; numberOfHardLinks) &#123;</span><br><span class="line">            hardLinksToAvoidGarbageCollection.removeLast();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeGarbageCollectedItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SoftEntry sv;</span><br><span class="line">    <span class="keyword">while</span> ((sv = (SoftEntry) queueOfGarbageCollectedEntries.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      delegate.removeObject(sv.key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 软引用内部类，key为强引用，value为软应用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftEntry</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line"></span><br><span class="line">    SoftEntry(Object key, Object value, ReferenceQueue&lt;Object&gt; garbageCollectionQueue) &#123;</span><br><span class="line">      <span class="comment">//将value包装为软引用，并加入garbageCollectionQueue</span></span><br><span class="line">      <span class="keyword">super</span>(value, garbageCollectionQueue);</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="SerializedCache">SerializedCache</h4><p>通过序列化及反序列化，来进行<strong>防御性拷贝</strong>，即每次通过相同key获取的对象都是不同的对象，以防止A线程拿到对象后，修改对象，B线程拿到修改后的对象，关于防御性拷贝可以看 <a href="https://zhucj94.github.io/article/ad01bc3e.html">https://zhucj94.github.io/article/ad01bc3e.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span> || object <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">      delegate.putObject(key, serialize((Serializable) object));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"SharedCache failed to make a copy of a non-serializable object: "</span> + object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">return</span> object == <span class="keyword">null</span> ? <span class="keyword">null</span> : deserialize((<span class="keyword">byte</span>[]) object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] serialize(Serializable value) &#123;</span><br><span class="line">    <span class="keyword">try</span> (ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos)) &#123;</span><br><span class="line">      oos.writeObject(value);</span><br><span class="line">      oos.flush();</span><br><span class="line">      <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error serializing object.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Serializable <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    Serializable result;</span><br><span class="line">    <span class="keyword">try</span> (ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(value);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> CustomObjectInputStream(bis)) &#123;</span><br><span class="line">      result = (Serializable) ois.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error deserializing object.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="TransactionalCache">TransactionalCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="comment">// 查询二级缓存</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 将查询转交给被装饰的Executor，进入前文所提到的BaseExecutor的子类</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachingExecutor初始化时，会初始化TransactionalCacheManager，二级缓存是由TransactionalCacheManager来管理的，TransactionalCacheManager会使用TransactionalCache来装饰Cache，<strong>TransactionalCache的设计十分有意思，put缓存只是暂存于当前线程中，只有当commit时才会将缓存写入。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTransactionalCache(cache).getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用TransactionalCache装饰Cache</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalCaches.computeIfAbsent(cache, TransactionalCache::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Cache delegate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> clearOnCommit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">  <span class="comment">//未命中列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Object&gt; entriesMissedInCache;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">    <span class="comment">// 从被装饰的Cache中获取</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="comment">// 如果值为空，加入未命中列表</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// put只是将键值存入entriesToAddOnCommit，而不交给被装饰的Cache，从entriesToAddOnCommit名字也能看出，即提交后再添加，这样其他线程就不能看到未提交的数据。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将entriesToAddOnCommit的键值交给被装饰的Cache</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果未命中列表数据不在entriesToAddOnCommit中，则在被装饰的Cache存入null值，防止缓存穿透</span></span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于flushPendingEntries我有个疑问，当A线程entriesMissedInCache存在key test，B线程插入了test且提交，此时A线程再执行delegate.putObject(test, null);，这样会造成在下一次清空缓存前，关于key的查询均为脏数据</strong></p><h3 id="命中条件">命中条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">  return delegate.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际是交个被装饰的Executor，调用BaseExecutor.createCacheKey，在一级缓存中详细介绍过createCacheKey，命中条件如下，与一级缓存不同在于不用相同的session，至于为什么请看Cache链的组装这一小节。</p><ol><li><strong>相同的方法（MappedStatement）</strong></li><li><strong>相同sql，参数</strong></li><li><strong>相同查询范围，即偏移量，limit</strong></li></ol><h3 id="清空条件">清空条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二级缓存清空，必须设置flushCache=“true”。调用情况如下，即查询和修改均会清空缓存。<br><img src="/images/mybatis/2_cache_clear.png" alt="avatar"></p><h3 id="Cache链的组装">Cache链的组装</h3><p>组装调用位于MapperBuilderAssistant，采用建造者模式，《effective java》上提到过，当参数较多时，使用建筑中模式代替构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> blocking,</span></span></span><br><span class="line"><span class="function"><span class="params">    Properties props)</span> </span>&#123;</span><br><span class="line">  Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">      .implementation(valueOrDefault(typeClass, PerpetualCache<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">      .<span class="title">addDecorator</span>(<span class="title">valueOrDefault</span>(<span class="title">evictionClass</span>, <span class="title">LruCache</span>.<span class="title">class</span>))</span></span><br><span class="line"><span class="class">      .<span class="title">clearInterval</span>(<span class="title">flushInterval</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">size</span>(<span class="title">size</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">readWrite</span>(<span class="title">readWrite</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">blocking</span>(<span class="title">blocking</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">properties</span>(<span class="title">props</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">build</span>()</span>;</span><br><span class="line">  configuration.addCache(cache);</span><br><span class="line">  currentCache = cache;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入CacheBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setDefaultImplementations();</span><br><span class="line">  <span class="comment">// 获取基础Cache，默认为PerpetualCache，与一级缓存一致</span></span><br><span class="line">  Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">  setCacheProperties(cache);</span><br><span class="line">  <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">  <span class="keyword">if</span> (PerpetualCache<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cache</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">      <span class="comment">//使用缓存淘汰策略装饰Cache，默认为LruCache</span></span><br><span class="line">      cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">      setCacheProperties(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    cache = setStandardDecorators(cache);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cache</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">"size"</span>)) &#123;</span><br><span class="line">      metaCache.setValue(<span class="string">"size"</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">      ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">      cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用日志装饰Cache，打印缓存命中率等信息</span></span><br><span class="line">    cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    <span class="comment">//使用同步装饰Cache，加锁</span></span><br><span class="line">    cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">    <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">      <span class="comment">//使用阻塞装饰Cache，当在缓存中未找到该元素时，它将对缓存键设置锁定，其他线程将等待直到该元素被填充，而不是访问数据库，即防止缓存击穿</span></span><br><span class="line">      cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Error building standard cache decorators.  Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完后，Cache对象如下，注意<strong>delegate</strong>，<strong>除了PerpetualCache外，均为装饰器，并且一层装饰一层，组成非标准的责任链</strong><br><img src="/images/mybatis/cache_ins.png" alt="avatar"></p><p>调用栈信息如下<br><img src="/images/mybatis/2_cache_invoke.png" alt="avatar"><br>即二级缓存的构建是在SqlSessionFactory初始化时，这也解释了为什么二级缓存命中条件不包含相同的session了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;MyBatis二级缓存的调用逻辑位于&lt;strong&gt;CachingExecutor&lt;/strong&gt;中&lt;/p&gt;&lt;h3 id=&quot;Cache及其子类&quot;&gt;Cache及其子类&lt;/h3&gt;&lt;p&gt;Mybatis使用Cache及子类来囊括所有缓存实现&lt;br&gt;所有子类如下图（idea查看 类右键 -&amp;gt; Diagrams -&amp;gt; show Diagrams -&amp;gt; ctrl+alt+b选择所有子类）&lt;br&gt;&lt;img src=&quot;/images/mybatis/cache_child.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://zhucj94.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码之一级缓存</title>
    <link href="https://zhucj94.github.io/article/7dd9b5ec.html"/>
    <id>https://zhucj94.github.io/article/7dd9b5ec.html</id>
    <published>2020-07-19T09:39:32.000Z</published>
    <updated>2020-07-29T14:23:30.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。</p><hr><p>MyBatis一级缓存的调用逻辑位于<strong>BaseExecutor</strong>中</p><h3 id="存储结构">存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PerpetualCache localCache</span><br></pre></td></tr></table></figure><p>PerpetualCache是通过HashMap来存储的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>localCache的key是CacheKey对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLIER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line">  <span class="comment">//hash计算时乘的倍数,默认构造会赋值DEFAULT_MULTIPLIER</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier; </span><br><span class="line">  <span class="comment">//hash码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode; </span><br><span class="line">  <span class="comment">//不乘倍数的hash码累加值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="comment">//调用update方法的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//所有update对象</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 每次update便修改hashcode，count，checksum，updateList</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 比较hashcode，count，checksum，updateList</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的命中条件">缓存的命中条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  <span class="comment">//1.方法名</span></span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  <span class="comment">//2.偏移量</span></span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  <span class="comment">//3.查询数量上限</span></span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  <span class="comment">//4.sql</span></span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.参数</span></span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//6.环境</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出一级缓存命中条件是</p><ol><li><strong>相同的方法（MappedStatement）</strong></li><li><strong>相同sql，参数</strong></li><li><strong>相同查询范围，即偏移量，limit</strong></li><li><strong>相同的session</strong>，此代码中未体现，但是localCache在BaseExecutor中，而BaseExecutor的创建是在初始化session时，调用栈信息如下图。</li></ol><p><img src="/images/mybatis/1_cache_invoke.png" alt="avatar"></p><h3 id="缓存清除条件">缓存清除条件</h3><p>PerpetualCache通过clear方法来清空缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用情况如下图<br><img src="/images/mybatis/first_cache_clear.png" alt="avatar"></p><ol><li>回滚</li><li>提交</li><li>修改</li><li>查询，当设置flushCache=&quot;true&quot;时，默认为false</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于事务提交会清除缓存，所以要用到一级缓存，还需要在同一事务中</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;&lt;p&gt;在阅读MyBatis源码前，建议先去github上clone MyBatis以及MyBatis parent源码，在本地搭建测试环境，以供idea在源码中打断点调试。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;MyBatis一级缓存的调用逻辑位于&lt;strong&gt;BaseExecutor&lt;/strong&gt;中&lt;/p&gt;&lt;h3 id=&quot;存储结构&quot;&gt;存储结构&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; PerpetualCache localCache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;PerpetualCache是通过HashMap来存储的&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PerpetualCache&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cache&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;Object, Object&amp;gt; cache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="MyBatis" scheme="https://zhucj94.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="https://zhucj94.github.io/article/47519a60.html"/>
    <id>https://zhucj94.github.io/article/47519a60.html</id>
    <published>2020-07-14T13:56:29.000Z</published>
    <updated>2020-07-24T06:18:36.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化数据类型的原则">优化数据类型的原则</h3><ul><li><p>更小的通常更好<br>更小的数据类型通常更快，因为其占用更少的磁盘，内存，CPU缓存，处理时需要的CPU周期也更少。</p></li><li><p>简单就好<br>简单的数据类型的操作通常需要更少的CPU，例如整型比字符串操作代价低，因为字符集和排序规则使字符比较比整型比较更复杂。</p></li><li><p>尽量避免NULL<br>可为NULL的列使索引，索引统计和值的比较更为复杂，当可为NULL的列被索引时，每个索引需额外的一个字节。</p></li></ul><h3 id="整数类型">整数类型</h3><p>TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT，分别使用8，16，24，32，64位存储空间，范围从$-2^{N-1}$ 到 $2^{N-1} -1$ ，可选UNSIGNED属性，即不允许负，这样正数上线提高一倍。</p><p><strong>指定的宽度通常是没有意义的，例如INT(11)，它不会限制值的合法范围，只规定MySQL交互工具来显示字符个数。</strong></p><h3 id="实数类型">实数类型</h3><p>DECIMAL，FLOAT，DOUBLE<br>DECIMAL用于存储精确的小数，5.0以后支持精确计算。通常DECIMAL比FLOAT，DOUBLE占用更多的空间。因为需要额外的空间和计算开销，<strong>尽量只在对小数进行精确计算时使用DECIMAL（例如钱），其余情况使用浮点型即可，在数据量比较大时，可以考虑使用BIGINT代替DECIMAL，将存储的数据乘相应位数存储。</strong></p><h3 id="字符串类型">字符串类型</h3><ul><li>VARCHAR 与 CHAR<br>VARCHAR<strong>是变长的</strong>，它仅需要使用必要的空间，它需要使用1或2个字节表示字符串的长度，它节约了空间，但是UPDATE可能使行比原来更长，占用的空间更大，如果页内没有空余的空间存储，那么InnoDB需要分裂页使行放进页中。</li></ul><p>CHAR是<strong>定长的</strong>，MySQL总是根据定义的字符串长度分配足够的空间，MySQL会<strong>删除末尾的空格</strong>，它适合存储所有值都接近同一长度，例如密码的MD5值。</p><ul><li>BLOB 与 TEXT<br>BLOB与TEXT仅有大的不同是BLOB是二进制，而TEXT是字符集，TEXT有字符集和排序规则，而BLOB没有。</li></ul><p>MySQL只对BLOB和TEXT的最前max_sort_length字节排序，而不是整个字符串。</p><ul><li>ENUM<br>ENUM把一些不重复的字符串存储成一个预定义的集合，MySQL存储ENUM时非常紧凑，会将值压缩到一个或两个字节中。<strong>MySQL实际存储ENUM为整数，而不是字符串，表示其在集合中的位置。</strong></li></ul><p>ENUM按照存储的整数进行排序，而不是定义的字符串。</p><p>添加或删除字符串只能用ALTER TABLE，对于未来会发生改变的字符串，使用枚举不太好。<br>ENUM与VARCHAR进行关联查询时，效率会变低，可能原因是ENUM关联时进行了一次转化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优化数据类型的原则&quot;&gt;优化数据类型的原则&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;更小的通常更好&lt;br&gt;更小的数据类型通常更快，因为其占用更少的磁盘，内存，CPU缓存，处理时需要的CPU周期也更少。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;简单就好&lt;br&gt;简单的数据类型的操作通常需要
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL第3版" scheme="https://zhucj94.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC3%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引（2）</title>
    <link href="https://zhucj94.github.io/article/be964bf6.html"/>
    <id>https://zhucj94.github.io/article/be964bf6.html</id>
    <published>2020-06-25T12:53:06.000Z</published>
    <updated>2020-07-24T06:18:36.278Z</updated>
    
    <content type="html"><![CDATA[<p>本文探讨**多列索引（类型为B-TREE）**对哪些查询有效<br>Mysql版本为5.7<br>下面的sql均是基于下表~</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`emp`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`num`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`dept_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_age_deptid_name <span class="keyword">ON</span> emp(age,dept_id,<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><h3 id="explain关键字">explain关键字</h3><p><img src="/images/index/explain.png" alt="avatar"></p><ul><li>possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定被查询实际使用。</li><li>key：<strong>实际使用的索引。如果为NULL，则没有使用索引</strong>。</li><li>key_len：表示索引中使用的字节数，能够帮你检查是否充分的利用上了索引。</li><li>extra：重要的额外信息<ul><li>Using filesort：无法使用索引排序，使用效率低的文件排序</li><li>Using temporary：使用临时表保存中间结果,常见于 order by 和 group by</li><li>Using index condition：使用索引条件下推（5.6加入）</li><li>Using index：使用覆盖索引，不需要回表</li><li>Using where</li><li>Using join buffer</li><li>impossible where</li><li>select tables optimized away</li></ul></li></ul><h3 id="最左前缀原则">最左前缀原则</h3><p>如果索引了多列，<strong>查询从索引的最左列开始并且不跳过索引中的列。</strong><br><img src="/images/index/left1.png" alt="avatar"></p><p><img src="/images/index/left2.png" alt="avatar"></p><p><img src="/images/index/left3.png" alt="avatar"></p><p>图2由于不是从索引最左列开始，所以没有用到索引（key为NULL）<br>图3虽然用到了索引，但是跳过了dept_id，只用到了索引的一部分（key_len 5 &lt; 93）</p><h3 id="不在索引列上做任何操作-索引不能是表达式的一部分">不在索引列上做任何操作(索引不能是表达式的一部分)</h3><p>计算、函数、(自动or手动)类型转换，会导致索引失效<br><img src="/images/index/oper1.png" alt="avatar"></p><p><img src="/images/index/oper2.png" alt="avatar"></p><p><img src="/images/index/oper3.png" alt="avatar"></p><p>图1由于在索引上计算导致无法使用索引<br>图2由于在索引上使用了函数导致无法使用索引<br>图3由于在name上有类型转换（<strong>name为varchar，123没有引号</strong>），导致name失效（key_len 10&lt; 93）</p><h3 id="范围条件右侧的列无法使用索引">范围条件右侧的列无法使用索引</h3><p><img src="/images/index/range.png" alt="avatar"><br>由于age使用范围查询，所以无法使用范围查询右侧的dept_id和name（key_len 5 &lt; 93）</p><h3 id="不等于无法使用索引">不等于无法使用索引</h3><p><img src="/images/index/notequal.png" alt="avatar"><br>由于age使用了不等于，所以无法使用索引</p><h3 id="is-not-null无法使用索引，is-null可以">is not null无法使用索引，is null可以</h3><p><img src="/images/index/isnotnull.png" alt="avatar"></p><h3 id="like以通配符开头不能使用索引，以通配符结束可以">like以通配符开头不能使用索引，以通配符结束可以</h3><p><img src="/images/index/like.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文探讨**多列索引（类型为B-TREE）**对哪些查询有效&lt;br&gt;Mysql版本为5.7&lt;br&gt;下面的sql均是基于下表~&lt;/p&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引（1)</title>
    <link href="https://zhucj94.github.io/article/b5580210.html"/>
    <id>https://zhucj94.github.io/article/b5580210.html</id>
    <published>2020-06-23T08:43:54.000Z</published>
    <updated>2020-07-24T06:18:36.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前缀索引和索引选择性">前缀索引和索引选择性</h3><ul><li>前缀索引<br>前缀索引是一种能使索引更小，更快的方式，即只索引开始的部分字符，这样可以节约索引空间，提高索引效率。<br>对于BLOB，TEXT，很长的VARCHAR列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dept <span class="keyword">add</span> <span class="keyword">key</span>(<span class="keyword">name</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>但是这也会降低索引选择性。</p><ul><li><p>索引选择性<br><strong>不重复的索引值和数据表的记录总数的比值，索引选择性越高则查询效率越高</strong>，因为选择性高的索引能让MySQL在查找时过滤更多的行。</p></li><li><p>计算索引选择性</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">3</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel3,</span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">4</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel4,</span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span> ( <span class="keyword">NAME</span>, <span class="number">5</span> ) ) / <span class="keyword">count</span>( <span class="number">1</span> ) sel5</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    dept</span><br></pre></td></tr></table></figure><p>一般来说能够接近0.031，基本就可用。</p><h3 id="多列索引及索引列的顺序">多列索引及索引列的顺序</h3><ul><li>多列索引<br>即索引包含多列，例如下篇文章的idx_age_deptid_name</li></ul><p>在多个列上建立独立的单列索引大部分情况并不能提高查询性能（查询条件不止一个的情况），因为<strong>早期MySQL只能使用其中一个单列索引，5.0后引入了索引合并（index merge）策略，即可以同时使用几个索引，并将结果合并，但是在合并操作上会耗费大量资源，且MySQL还遵循range优先原则，即一个索引的连续段包含所有符合查询条件的索引时，不使用索引合并</strong>。</p><ul><li>多列索引顺序经验法则<br>将选择性最高的列放到索引最前列</li></ul><h3 id="聚簇索引">聚簇索引</h3><p>聚簇索引不是一种索引类型，而是一种数据存储方式。<br>InnoDB的聚簇索引实际上在<strong>同一结构中保存了B-Tree索引和数据行</strong>，即当表有聚簇索引时，数据行实际存放在索引的叶子页中。</p><p><img src="/images/index/clustered_index.png" alt="avatar"></p><p><strong>InnoDB一定会有聚簇索引</strong>，有主键时就是主键，没有定义主键，InnoDB会选择唯一的非空索引代替，如有没有这样的索引，会隐式定义一个主键。</p><ul><li><p>缺点</p><ul><li>插入速度依赖插入顺序，如果不按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE重新组织表。下面两张图分别为id为递增和UUID的情况。<br><img src="/images/index/insert2.png" alt="avatar"></li></ul><p><img src="/images/index/insert1.png" alt="avatar"></p><ul><li>更新聚簇索引列代价高，因为会强制将被更新的行移动到新位置。</li><li>可能会有‘页分裂（page split）’问题，当行插入到某个已满的页中，存储引擎会将页分裂成两个页，这会导致表占用更多的空间。</li><li><strong>InnoDB的二级索引会有‘回表’问题，因为二级索引叶子节点保存的是行的主键值，而不是‘行指针’，所以使用二级索引的查询需要先找到二级索引的叶子节点获取主键值，然后去聚簇索引查找对应的行。</strong></li></ul></li></ul><h3 id="覆盖索引">覆盖索引</h3><p>如果一个索引包含所有需要查询的字段的值，就称为覆盖索引，MySQL只能用B-TREE索引做覆盖索引，因为只有B-TREE索引存储了索引列的值。</p><p><strong>如果InnoDB的查询能用到覆盖索引，那么就可以避免‘回表’。</strong></p><p>如果查询的列由索引和主键组成，也是覆盖索引，因为二级索引的叶子节点保存了主键值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前缀索引和索引选择性&quot;&gt;前缀索引和索引选择性&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;前缀索引&lt;br&gt;前缀索引是一种能使索引更小，更快的方式，即只索引开始的部分字符，这样可以节约索引空间，提高索引效率。&lt;br&gt;对于BLOB，TEXT，很长的VARCHAR列，必须使用前缀索引，因为
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="高性能MySQL第3版" scheme="https://zhucj94.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC3%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB之缓冲池(buffer pool)</title>
    <link href="https://zhucj94.github.io/article/3e77f45e.html"/>
    <id>https://zhucj94.github.io/article/3e77f45e.html</id>
    <published>2020-06-11T14:20:10.000Z</published>
    <updated>2020-07-24T06:18:36.150Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL作为一个存储系统，具有 <em><strong>buffer pool</strong></em> 机制，以避免每次查询都进行磁盘IO。</p><h3 id="缓存什么">缓存什么</h3><p>缓存表数据与索引数据</p><h3 id="预读（read-ahead）">预读（read-ahead）</h3><ul><li>page是InnoDB存储引擎的最小磁盘单位，一次至少读取一个page，extent是由连续的page组成的空间。</li><li>如果一个extent中被顺序读取的page超过或者等于innodb_read_ahead_threshold时，InnoDB将会异步的将下一个extent读取到buffer pool中（以linear read-ahead概述，random read-ahead在5.5后被废弃）。</li><li>预读的依据是<strong>局部性原理</strong> : CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</li></ul><h3 id="淘汰算法">淘汰算法</h3><p>采用改进版的LRU算法，传统的LRU算法会遇到两个问题</p><ul><li><p>预读失败<br>由于预读，提前将page放入缓冲池，但最终没有从页中读取数据。<br>改进：</p><ul><li>将LRU分为新生代（new sublist），老生代（old sublist）。</li><li>新老生代首尾相连。</li><li>新页加入缓冲池时，只加入老生代头部，如果数据被真正读取到，才会加入新生代头部，如果没有被读取，则会比新生代里的数据更早被淘汰</li></ul></li><li><p>缓冲池污染<br>当执行某个SQL时，要批量扫描大量数据（例如未命中索引，而全表扫描），导致大量热数据被淘汰。<br>改进：</p><ul><li>插入老生代头部的页，即使立刻被访问，也不会放入新生代头部。</li><li>只有满足 <em><strong>被访问</strong></em> 且 <em><strong>在老生代停留时间大于T</strong></em>，才会被放入新生代头部。</li></ul></li></ul><p><img src="/images/InnoDB/newlru.png" alt="avatar"></p><h3 id="相关参数">相关参数</h3><ul><li>innodb_buffer_pool_size<br>缓冲池的大小</li><li>innodb_old_blocks_pct<br>老生代占整个LRU链长度的比例，默认是37</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL作为一个存储系统，具有 &lt;em&gt;&lt;strong&gt;buffer pool&lt;/strong&gt;&lt;/em&gt; 机制，以避免每次查询都进行磁盘IO。&lt;/p&gt;&lt;h3 id=&quot;缓存什么&quot;&gt;缓存什么&lt;/h3&gt;&lt;p&gt;缓存表数据与索引数据&lt;/p&gt;&lt;h3 id=&quot;预读（read-ahea
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（3x）</title>
    <link href="https://zhucj94.github.io/article/5533cdb0.html"/>
    <id>https://zhucj94.github.io/article/5533cdb0.html</id>
    <published>2020-05-16T08:15:16.000Z</published>
    <updated>2020-07-24T06:18:36.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="行锁策略">行锁策略</h3><ol><li>加锁的基本单位是临键锁。（记录锁+间隙锁，左开右闭区间）</li><li>查找到数据才会加记录锁。</li><li>唯一索引上的等值查询（命中），间隙锁退化为记录锁。</li><li>辅助索引上的等值查询（命中），会在右侧相邻间隙加上间隙锁。</li><li>唯一索引上的范围查询（等值条件命中，例如&lt;=的等于命中）,会在右侧相邻间隙加上临键锁。</li></ol><h3 id="例子">例子</h3><p>// todo</p><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p><p><a href="https://blog.guitar-coder.cn/MySql%E9%94%81-%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81.html" target="_blank" rel="noopener">https://blog.guitar-coder.cn/MySql锁-间隙锁和临键锁.html</a></p><p><a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a></p><p><a href="https://time.geekbang.org/column/article/75659" target="_blank" rel="noopener">https://time.geekbang.org/column/article/75659</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;行锁策略&quot;&gt;行锁策略&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;加锁的基本单位是临键锁。（记录锁+间隙锁，左开右闭区间）&lt;/li&gt;&lt;li&gt;查找到数据才会加记录锁。&lt;/li&gt;&lt;li&gt;唯一索引上的等值查询（命中），间隙锁退化为记录锁。&lt;/li&gt;&lt;li&gt;辅助索引上的等值查询（命中），会在
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（3）</title>
    <link href="https://zhucj94.github.io/article/6f88bd9.html"/>
    <id>https://zhucj94.github.io/article/6f88bd9.html</id>
    <published>2020-05-14T13:56:50.000Z</published>
    <updated>2020-07-24T06:18:36.171Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks. (InnoDB执行行级锁方式是当它搜索或扫描表索引时，会在遇到的索引上加共享或排他锁，故行级锁实际上时索引记录锁)</p><h3 id="记录锁（Record-Locks）">记录锁（Record Locks）</h3><ul><li><p>定义<br>A record lock is a lock on an <strong>index record</strong> （记录锁锁定的是<strong>索引</strong>记录）</p></li><li><p>例子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM WHERE id &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>它会在id=1的索引记录上加锁，以阻止其他事务插入，更新，删除id=1的这一行</p><h3 id="间隙锁（Gap-Locks）">间隙锁（Gap Locks）</h3><ul><li>定义<br>A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.（间隙锁锁定的是<strong>索引</strong>记录间的间隔，或是第一条索引之前的范围，亦或是最后一条索引之后的范围）</li><li>例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id BETWEEN 10 and 20 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>会锁定（10，20），防止其他事务插入，更新，删除id在（10，20）间的记录</p><p><strong>对于使用唯一索引来锁定唯一行的语句，不会产生间隙锁，而是使用记录锁。</strong> (This does not include the case that the search condition includes only some columns of a multiple-column unique index; in that case, gap locking does occur. 这句话暂时没明白)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM WHERE id &#x3D; 1 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>如果id未建立索引或具有非唯一索引，则该语句会产生间隙锁，锁定前面的间隙。</p><h3 id="临键锁（Next-Key-Locks）">临键锁（Next-Key Locks）</h3><ul><li>定义<br>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.（临键锁是锁定索引的记录锁和锁定该索引之前区间的间隙锁的组合）</li></ul><p><strong>默认情况下（RR），InnoDB使用临键锁进行搜索和索引扫描。</strong></p><p>假设索引记录为 10, 11, 13, 20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure><h3 id="插入意向锁（Insert-Intention-Locks）">插入意向锁（Insert Intention Locks）</h3><ul><li>定义<br>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. （插入意向锁时插入行之前的插入操作设置的一种间隙锁）</li></ul><p>多个事务，在同一个索引，同一个范围区间插入记录时，<strong>如果插入的位置不冲突，不会阻塞彼此。</strong></p><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the in
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（2）</title>
    <link href="https://zhucj94.github.io/article/be44ecbc.html"/>
    <id>https://zhucj94.github.io/article/be44ecbc.html</id>
    <published>2020-05-12T13:18:18.000Z</published>
    <updated>2020-07-24T06:18:36.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共享-排他锁（Shared-and-Exclusice-Locks）">共享/排他锁（Shared and Exclusice Locks）</h3><p><strong>行级锁</strong></p><ul><li><p>定义</p><ul><li><strong>事务</strong>拿到某一行记录的共享S锁，才可以读取（当前读）这一行；</li><li><strong>事务</strong>拿到某一行记录的排他X锁，才可以修改或者删除这一行；</li></ul></li><li><p>加锁方式</p><ul><li>共享锁（S）：SELECT … LOCK IN SHARE MODE</li><li>排他锁（X）：SELECT … FOR UPDATE （<strong>update/delete/insert自动加排他锁</strong>）</li></ul></li><li><p>互斥关系</p></li></ul><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">兼容</td><td style="text-align:center">互斥</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td></tr></tbody></table><h3 id="意向锁（Intention-Locks）">意向锁（Intention Locks）</h3><p><strong>不与行级锁冲突表级锁</strong></p><ul><li><p>分类</p><ul><li>意向共享锁(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁。</li><li>意向排它锁(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁。</li></ul></li><li><p>intention locking protocol</p><ul><li>事务要获得某些<strong>行</strong>的S锁，必须先获得表的IS锁。</li><li>事务要获得某些<strong>行</strong>的X锁，必须先获得表的IX锁。</li></ul></li><li><p>互斥关系（<strong>下表的S/X锁是表级的!!!</strong>）</p></li></ul><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">X</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">IS</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td></tr><tr><td style="text-align:center">IX</td><td style="text-align:center">互斥</td><td style="text-align:center">兼容</td><td style="text-align:center">互斥</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">IS</td><td style="text-align:center">互斥</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr></tbody></table><ul><li>判断冲突时的作用<br>无意向锁 ：<ul><li>判断表是否被其他事务加表锁。</li><li>判断表中的每一行是否被其他事务加行锁。<br>有意向锁 ：</li><li>判断表是否被其他事务加表锁。</li><li>判断表是否被其他事务加意向锁。</li></ul></li></ul><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;共享-排他锁（Shared-and-Exclusice-Locks）&quot;&gt;共享/排他锁（Shared and Exclusice Locks）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;行级锁&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;定义&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;stro
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁（1）自增锁（AUTO-INC Locks）</title>
    <link href="https://zhucj94.github.io/article/32458d66.html"/>
    <id>https://zhucj94.github.io/article/32458d66.html</id>
    <published>2020-05-10T13:27:21.000Z</published>
    <updated>2020-07-24T06:18:36.163Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文不介绍MySQL的读表锁（LOCK TABLE table_name READ）和写表锁（LOCK TABLE table_name WRITE</strong></p><p>自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。</p><h3 id="insert分类">insert分类</h3><ul><li><p>Simple inserts<br>Statements for which the number of rows to be inserted can be determined in advance (when the statement is initially processed). This includes single-row and multiple-row INSERT and REPLACE statements that do not have a nested subquery, but not INSERT … ON DUPLICATE KEY UPDATE.</p></li><li><p>Bulk inserts<br>Statements for which the number of rows to be inserted (and the number of required auto-increment values) is not known in advance.This includes INSERT … SELECT, REPLACE … SELECT, and LOAD DATA statements, but not plain INSERT. InnoDB will assign new values for the AUTO_INCREMENT column one at a time as each row is processed.</p></li><li><p>Mixed-mode inserts<br>These are “simple insert” statements that specify the auto-increment value for some (but not all) of the new rows. An example follows, where c1 is an AUTO_INCREMENT column of table t1:</p></li></ul><p>INSERT INTO t1 (c1,c2) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’);</p><p>Another type of “mixed-mode insert” is INSERT … ON DUPLICATE KEY UPDATE, which in the worst case is in effect an INSERT followed by a UPDATE, where the allocated value for the AUTO_INCREMENT column may or may not be used during the update phase.</p><h3 id="锁模式（参数innodb-autoinc-lock-mode）">锁模式（参数innodb_autoinc_lock_mode）</h3><ul><li><p>innodb_autoinc_lock_mode = 0 （traditional）</p><ul><li>此模式与innodb_autoinc_lock_mode存在前的行为相同，对于所有的‘INSERT-like’语句，都会使用特殊的AUTO-INC table-level lock，保持到语句结束。这确保了任何给定语句分配的自动增量值是连续的。</li></ul></li><li><p>innodb_autoinc_lock_mode = 1 （consecutive）</p><ul><li>默认的模式</li><li>发生Simple inserts时，在分配AUTO_INCREMENT期间，会使用轻量级的锁，获取到AUTO_INCREMENT后就释放锁，如果其他事务持有AUTO-INC table-level lock，获取轻量级锁也会等待。</li><li>发生Bulk inserts时，会使用特殊的AUTO-INC table-level lock，保持到语句结束。</li><li>发生Mixed-mode inserts时，一些行指定了AUTO_INCREMENT，将分配比要插入的行数更多的AUTO_INCREMENT，所有AUTO_INCREMENT是连续生成的，多余的丢失。</li></ul></li><li><p>innodb_autoinc_lock_mode = 2 （interleaved）</p><ul><li>对于所有的‘INSERT-like’语句不加锁</li><li>对于Bulk inserts，AUTO_INCREMENT可能不连续</li><li>binlog为SBR模式时，数据复制或恢复不安全</li></ul></li></ul><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html#innodb-auto-inc-locks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文不介绍MySQL的读表锁（LOCK TABLE table_name READ）和写表锁（LOCK TABLE table_name WRITE&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的MVCC（Multi Versioning Concurrency Control）</title>
    <link href="https://zhucj94.github.io/article/b93dd38a.html"/>
    <id>https://zhucj94.github.io/article/b93dd38a.html</id>
    <published>2020-05-05T12:25:29.000Z</published>
    <updated>2020-07-24T06:18:36.144Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MVCC主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突</strong>，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。（读指快照读）</p><h3 id="定义">定义</h3><p>InnoDB is a multi-versioned storage engine: it keeps information about old versions of changed rows, to support transactional features such as concurrency and rollback.This information is stored in the tablespace in a data structure called a rollback segment（InndDB是多版本的存储引擎，它保留已更改行旧版本信息，以支持事务的并发和回滚，这些信息保存在被称为回滚段的表空间数据结构中）</p><h3 id="实现细节">实现细节</h3><h4 id="隐藏字段">隐藏字段</h4><ul><li>DB_TRX_ID：6字节，记录每一行最近一次修改它的事务ID。</li><li>DB_ROLL_PTR：7字节，记录指向回滚段UNDO LOG的指针。</li><li>DB_ROW_ID：6字节，单调递增的行ID。</li></ul><h4 id="undo-log">undo log</h4><ul><li><p>分类</p><ul><li>insert undo log：事务在insert操作时产生的undo log，只用于事务回滚，在事务提交时立即被丢弃。</li><li>update undo log：事务在update或delete操作时产生的undo log；在事务回归时需要，<strong>在快照读时也需要</strong>，不会随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。</li></ul></li><li><p>执行流程</p><ul><li>假设person表有如下数据</li></ul><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">age</th><th style="text-align:center">DB_ROW_ID</th><th style="text-align:center">DB_TRX_ID</th><th style="text-align:center">DB_ROLL_PTR</th></tr></thead><tbody><tr><td style="text-align:center">jerry</td><td style="text-align:center">24</td><td style="text-align:center">1</td><td style="text-align:center">null</td><td style="text-align:center">null</td></tr></tbody></table><ul><li><p>事务1将name修改为tom</p><ul><li>事务1获取并对该行加排他锁</li><li>将行数据拷贝到undo log中</li><li>将name改为tom，并经DB_TRX_ID改为事务1的ID,回滚指针指向之前拷贝到undo log的行数据</li><li>提交事务，释放排他锁<br><img src="/images/InnoDB/update-undo-log-4-mvcc1.png" alt="avatar"></li></ul></li><li><p>事务2将age改为30</p><ul><li>事务2获取并对该行加排他锁</li><li>将行数据拷贝到undo log中，发现该行记录已有undo log，将本次的拷贝作为链表的表头。</li><li>将age改为30，并经DB_TRX_ID改为事务2的ID,回滚指针指向之前拷贝到undo log的行数据</li><li>提交事务，释放排他锁<br><img src="/images/InnoDB/update-undo-log-4-mvcc2.png" alt="avatar"></li></ul></li></ul></li></ul><p>MVCC使用的是 <strong>update undo log ，undo log实际上就是存在rollback segment中旧记录链</strong></p><h4 id="Read-View">Read View</h4><p><strong>Read View 是用来做可见性判断的</strong>，当事务执行快照读时，会生成数据库当前的一个快照，记录并维护系统当前活跃事务的ID。</p><ul><li>算法（简化版）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id_list : 用来维护Read View生成时系统活跃的事务ID（分配的事务ID是递增的）</span><br><span class="line">up_limit_id：id_list中最小的事务ID</span><br><span class="line">low_limit_id：ReadView生成时刻系统尚未分配的下一个事务ID，**即已出现过最大的事务ID的+1**</span><br></pre></td></tr></table></figure><pre><code>+ 比较DB_TRX_ID与up_limit_id，如果小于，则当前事务能看到DB_TRX_ID所在的行数据，否则进入下一步。+ 比较DB_TRX_ID与low_limit_id，如果大于，则当前事务不能看到DB_TRX_ID所在的行数据，否则进入下一步。+ 判断DB_TRX_ID是否在id_list中，如果在，则当前事务不能看到DB_TRX_ID所在的行数据，否则能看到。</code></pre><ul><li><p>流程<br>将当前数据的DB_TRX_ID取出，与Read View维护活跃事务ID进行比较（通过上面的算法），如果如果不符合可见性，就通过DB_ROLL_PTR取undo log中的记录，将它的DB_TRX_ID与Read View维护活跃事务ID进行比较，如果还不符合，就取链表的下一条记录，直至满足可见性，那么这个DB_TRX_ID所在的旧纪录就是当前事务能看见的记录。</p></li><li><p>RR与RC下Read View生成时机<br><strong>RC隔离级别下，每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong><br>这就是RR的快照读能防止幻读，而RC不能的原因。</p></li></ul><p>参考<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-undo-logs.html</a></p><p><a href="https://blog.csdn.net/SnailMann/article/details/94724197" target="_blank" rel="noopener">https://blog.csdn.net/SnailMann/article/details/94724197</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;MVCC主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突&lt;/strong&gt;，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。（读指快照读）&lt;/p&gt;&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;&lt;p&gt;InnoDB is a multi-versioned
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB快照读与当前读</title>
    <link href="https://zhucj94.github.io/article/cdee20fb.html"/>
    <id>https://zhucj94.github.io/article/cdee20fb.html</id>
    <published>2020-05-04T13:51:31.000Z</published>
    <updated>2020-07-24T06:18:36.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快照读（Consistent-Nonlocking-Reads）">快照读（Consistent Nonlocking Reads）</h3><p>A consistent read means that InnoDB uses multi-versioning to present to a query a snapshot of the database at a point in time.（快照读是InnoDB使用多版本来查询某个时间点的快照）</p><p>Consistent read is the default mode in which InnoDB processes SELECT statements in READ COMMITTED and REPEATABLE READ isolation levels. A consistent read does not set any locks on the tables it accesses, and therefore other sessions are free to modify those tables at the same time a consistent read is being performed on the table.（快照读是RR和RC下处理SELECT的默认模式，快照读不在访问的表上设置任何锁，因此其他会话可以自由的修改这些表。）</p><h3 id="当前读（Locking-Reads）">当前读（Locking Reads）</h3><p>If you query data and then insert or update related data within the same transaction, the regular SELECT statement does not give enough protection. Other transactions can update or delete the same rows you just queried. （在同一事务中查询数据，然后更新或修改相关数据，快照读不能提供足够保护，其他事务可以修改或删除刚查询的行。）</p><p>InnoDB提供了 **SELECT … LOCK IN SHARE MODE（共享锁）**和 **SELECT … FOR UPDATE（排他锁）**提供额外的安全。</p><p>参考：<br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking-reads.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;快照读（Consistent-Nonlocking-Reads）&quot;&gt;快照读（Consistent Nonlocking Reads）&lt;/h3&gt;&lt;p&gt;A consistent read means that InnoDB uses multi-versioning 
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://zhucj94.github.io/article/93ac284c.html"/>
    <id>https://zhucj94.github.io/article/93ac284c.html</id>
    <published>2020-05-02T12:52:14.000Z</published>
    <updated>2020-07-24T06:18:36.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ACID">ACID</h3><ul><li>原子性(Atomicity)<br>事务是一个原子操作，其对数据的修改，要么全执行，要么全不执行。</li><li>一致性(Consistency)<br>事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</li><li>隔离性(Isolation)<br>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性(Durability)<br>事务完成后，它对于数据的修改是永久性的，其后的其他操作或故障都不应该造成影响。</li></ul><h3 id="并发事务造成的影响">并发事务造成的影响</h3><ul><li><p>脏读(Dirty Reads)<br>事务A读取到了事务B未提交的已修改数据，并操作了这些数据，此时事务B回滚，A依据脏数据做的操作可能不正确，不符合一致性。（例如，b=3，B事务将b改为4未提交，A事务读取到了，执行a=b+5，此时B回滚）</p></li><li><p>不可重复读(Non-Repeatable Reads)<br>事务A读取到了事务B已提交的修改数据（update，delete），不符合隔离性。</p></li><li><p>幻读(Phantom Reads)<br>事务A读取到了事务B已提交的新增数据，不符合隔离性。</p></li></ul><h3 id="隔离级别">隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">读数据一致性</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交(Read uncommitted)</td><td style="text-align:center">最低级别，只能保证不读取物理上损坏的数据</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">读已提交(Read committed)</td><td style="text-align:center">语句级</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可重复读(Repeatable read)</td><td style="text-align:center">事务级</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可序列化(Serializable)</td><td style="text-align:center">事务级</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>注：上表只是通常情况，<strong>InnoDB Repeatable read，通过MVCC解决普通读的幻读，通过间隙锁(Gap Locks)，临键锁(Next-Key Locks)解决 <em><strong>当前读</strong></em> 幻影读问题</strong></p><h3 id="自动提交">自动提交</h3><p>MySQL默认采用自动提交模式。即如果不是显示地开始一个事务，则每个查询都被当做一个事务执行提交操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ACID&quot;&gt;ACID&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;原子性(Atomicity)&lt;br&gt;事务是一个原子操作，其对数据的修改，要么全执行，要么全不执行。&lt;/li&gt;&lt;li&gt;一致性(Consistency)&lt;br&gt;事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://zhucj94.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2.0</title>
    <link href="https://zhucj94.github.io/article/1b404596.html"/>
    <id>https://zhucj94.github.io/article/1b404596.html</id>
    <published>2020-04-30T08:48:37.000Z</published>
    <updated>2020-07-24T06:18:36.215Z</updated>
    
    <content type="html"><![CDATA[<p>最近又对接微信，它对外开放数据的协议就是Oauth，把阮一峰大神的几篇文章摘取几段，加深对Oauth的理解。</p><p>Oauth（Open Authorization）是一种授权机制，核心是通过颁发令牌给第三方应用，使其可以携带令牌访问数据。</p><h3 id="令牌与密码的差异">令牌与密码的差异</h3><ul><li>令牌是短期的，<strong>到期后会失效</strong>，密码一般是长期的，用户不主动修改，不会改变。</li><li>令牌可被颁发者主动撤销，而密码一般不可由他人控制。</li><li>令牌的权限范围一般比密码小。</li></ul><a id="more"></a><h3 id="基本概念">基本概念</h3><ul><li>Third-party application：第三方应用程序，例如微信网站应用。</li><li>HTTP service：HTTP服务提供商，例如微信。</li><li>Resource Owner：资源所有者，例如微信用户。</li><li>User Agent：用户代理，浏览器。</li><li>Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul><h3 id="4种授权方式">4种授权方式</h3><ul><li><p>授权码模式（authorization code）</p><p>最安全的一种方式，适用于有后端的web应用</p><ol><li>资源所有者访问第三方应用，后者将前者导向认证服务器。</li><li>资源所有者选择是否给予第三方应用授权。</li><li>假设资源所有者给予授权，认证服务器将资源所有者导向第三方应用事先指定的&quot;重定向URI&quot;，同时附上一个授权码。</li><li>第三方应用收到授权码，向认证服务器申请令牌。这一步是在第三方应用的后台的服务器上完成的，对资源所有者不可见。</li><li>认证服务器核对了授权码和重定向URI，确认无误后，向第三方应用发送访问令牌（access token）和更新令牌（refresh token）。</li></ol></li><li><p>隐藏（简化）模式（implicit）</p><p>适用于纯前端应用</p><ol><li>客户端将用户导向认证服务器。</li><li>用户决定是否给于客户端授权。</li><li>假设用户给予授权，认证服务器将用户导向客户端指定的&quot;重定向URI&quot;，并带上访问令牌，token的位置是url锚点</li></ol></li><li><p>密码模式（resource owner password credentials）</p><p>适用于高度信任的应用</p><ol><li>资源拥有者向第三方应用提供用户名和密码。</li><li>第三方应用将用户名和密码发给认证服务器，向后者请求令牌。</li><li>认证服务器确认无误后，向客户端提供访问令牌。</li></ol></li><li><p>客户端模式（client credentials）</p><p>适用于没有前端的应用</p><ol><li>第三方应用向认证服务器进行身份认证，并要求一个访问令牌。</li><li>认证服务器确认无误后，直接返回访问令牌。</li></ol></li></ul><p>本文由阮一峰3篇oauth2.0文章总结而来。</p><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又对接微信，它对外开放数据的协议就是Oauth，把阮一峰大神的几篇文章摘取几段，加深对Oauth的理解。&lt;/p&gt;&lt;p&gt;Oauth（Open Authorization）是一种授权机制，核心是通过颁发令牌给第三方应用，使其可以携带令牌访问数据。&lt;/p&gt;&lt;h3 id=&quot;令牌与密码的差异&quot;&gt;令牌与密码的差异&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;令牌是短期的，&lt;strong&gt;到期后会失效&lt;/strong&gt;，密码一般是长期的，用户不主动修改，不会改变。&lt;/li&gt;&lt;li&gt;令牌可被颁发者主动撤销，而密码一般不可由他人控制。&lt;/li&gt;&lt;li&gt;令牌的权限范围一般比密码小。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Oauth2.0" scheme="https://zhucj94.github.io/tags/Oauth2-0/"/>
    
  </entry>
  
  <entry>
    <title>读写分离下数据库与缓存的一致性</title>
    <link href="https://zhucj94.github.io/article/9e1a046e.html"/>
    <id>https://zhucj94.github.io/article/9e1a046e.html</id>
    <published>2020-04-18T07:50:54.000Z</published>
    <updated>2020-07-24T06:18:36.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读操作">读操作</h3><ol><li>尝试从缓存get数据，结果没有命中。</li><li>从数据库获取数据，读从库。</li><li>把数据set到缓存，未来能够命中缓存。<br><img src="/images/cache/read.png" alt="avatar"></li></ol><h3 id="写操作">写操作</h3><ol><li>delete缓存。</li><li>操作数据库。<br><img src="/images/cache/write.png" alt="avatar"></li></ol><h3 id="为什么写操作先操作缓存，再操作数据库？">为什么写操作先操作缓存，再操作数据库？</h3><ul><li>如果操作数据库成功，但是操作缓存失败，会导致数据库与缓存的不一致。</li></ul><h3 id="写操作为什么不更新缓存，而是删除？">写操作为什么不更新缓存，而是删除？</h3><ul><li>使用更新，1成功，2失败，会导致缓存里是更新后的数据，数据库里是之前的数据，数据不一致。</li><li>使用删除，1成功，2失败，会导致缓存里没有数据，数据库里是之前的数据，数据没有不一致。只是下一次读取，会多一次cache miss。</li></ul><h3 id="写操作完成后，数据库主从同步未完成-主库是新数据-从库是旧数据-，此时读操作将旧数据写入缓存，怎么办？">写操作完成后，数据库主从同步未完成(主库是新数据,从库是旧数据)，此时读操作将旧数据写入缓存，怎么办？</h3><ul><li>方案一<ul><li>通过工具（canal）订阅从库的binlog，从库执行完写操作后，再次删除缓存，淘汰可能写入缓存的旧数据。</li></ul></li><li>方案二<ul><li>写操作后，将哪个库，哪个表，哪个主键三个信息拼装一个key写到cache里，这条记录的超时时间，设置为“主从同步所需时间”。</li><li>读操作第二步改为拼装key去缓存中查找，如果命中则强制读主库，否则读从库。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;读操作&quot;&gt;读操作&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;尝试从缓存get数据，结果没有命中。&lt;/li&gt;&lt;li&gt;从数据库获取数据，读从库。&lt;/li&gt;&lt;li&gt;把数据set到缓存，未来能够命中缓存。&lt;br&gt;&lt;img src=&quot;/images/cache/read.png&quot; alt=&quot;
      
    
    </summary>
    
    
    
      <category term="缓存" scheme="https://zhucj94.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://zhucj94.github.io/article/23a3bd72.html"/>
    <id>https://zhucj94.github.io/article/23a3bd72.html</id>
    <published>2020-04-02T06:22:14.000Z</published>
    <updated>2020-07-24T06:18:36.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常">对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><ul><li>如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。</li><li>用运行时异常来表明编程错误，例如数组的下标值在0到长度-1之间，ArrayIndexOutOfBoundsException表明违反了这个前提。按照惯例，<em><strong>错误（Error）往往被JVM保留下来使用，你实现的所有非受检的 throwable 都应该是 RuntimeExceptiond 子类。</strong></em></li></ul><a id="more"></a><h3 id="避免不必要的使用受检异常">避免不必要的使用受检异常</h3><ul><li>在谨慎使用的前提之下，受检异常可以提升程序的可读性；过分使用受检异常使api不方便，api必须位于try块中或者方法向上抛出异常。</li><li>可以使用下面两种方式部分替代受检异常。<ul><li>返回一个Optional，方法不抛出异常，只是返回一个空Optional，缺点是方法无法返回额外信息，而异常可以。</li><li>将受检异常变为非受检异常，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个boolean值，表明是否应该抛出异常，第二个方法正常执行，抛出非受检异常。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.action( args );</span><br><span class="line">&#125; <span class="keyword">catch</span> ( TheCheckedException e ) &#123;</span><br><span class="line">... <span class="comment">/* Handle exceptional condition */</span></span><br><span class="line">&#125;</span><br><span class="line">重构为下面</span><br><span class="line"><span class="keyword">if</span> ( obj.actionPermitted( args ) ) &#123;</span><br><span class="line">    obj.action( args );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">/* Handle exceptional condition */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种重构并非总是恰当的，如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在actionPermitted和action这两个调用的时间间隔之中，对象的状态有可能会发生变化。如果单独的actionPermitted方法必须重复action方法的工作，出于性能的考虑，这种API重构就不值得去做。</p><h3 id="抛出与抽象对应的异常">抛出与抽象对应的异常</h3><ul><li>如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抛出的异常时，往往会发生这种情况，为了避免这个问题，更高层的实现应该<em><strong>捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为异常转译(exception translation)</strong></em>，例如AbstractSequentialList.get(index)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>***尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它。***处理来自低层异常的最好做法是在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常，例如给低层传递参数之前，检查更高层方法的参数的有效性。其次的做法是，让更高层来悄悄地处理这些异常，从而将高层方法的调用者与低层的问题隔离开来，例如日志打印。</li></ul><h3 id="保证失败原子性">保证失败原子性</h3><ul><li>一般而言，***失败的方法调用应该使对象保持在被调用之前的状态。***具有这种属性的方法被称为具有失败原子性 (failure atomic)。</li><li>有5中方法保持失败原子性<ul><li>使用不可变对象。</li><li>在执行操作之前检查参数的有效性，例如Arraylist.get(index)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);</span><br><span class="line">  <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。</li><li>在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。</li><li>编写一段恢复代码 (recoverycode)，由它来拦截操作过程中发生的失败，以及便对象回滚到操作开始之前的状态上。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对可恢复的情况使用受检异常，对编程错误使用运行时异常&quot;&gt;对可恢复的情况使用受检异常，对编程错误使用运行时异常&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。&lt;/li&gt;&lt;li&gt;用运行时异常来表明编程错误，例如数组的下标值在0到长度-1之间，ArrayIndexOutOfBoundsException表明违反了这个前提。按照惯例，&lt;em&gt;&lt;strong&gt;错误（Error）往往被JVM保留下来使用，你实现的所有非受检的 throwable 都应该是 RuntimeExceptiond 子类。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="https://zhucj94.github.io/article/ad01bc3e.html"/>
    <id>https://zhucj94.github.io/article/ad01bc3e.html</id>
    <published>2020-03-30T11:09:10.000Z</published>
    <updated>2020-07-24T06:18:36.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检查参数有效性">检查参数有效性</h3><ul><li>大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。例如，索引值必须是非负数。<em><strong>在方法的开头检查参数，抛出适当的异常快速且清楚的结束方法</strong></em>。如果不检查参数，可能会出现令人困惑的异常，或者方法正常返回，但计算错误。</li><li>可以使用guava的Preconditions检查参数。</li></ul><a id="more"></a><h3 id="必要时进行防御性拷贝">必要时进行防御性拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                start + <span class="string">" after "</span> + end);</span><br><span class="line">                <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>***假定类的客户端尽力摧毁类不变量，防御性地编写程序。***Period看起来是不可变的，但是利用Date的可变性，就能打破不变性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Period(<span class="keyword">new</span> Date(), <span class="keyword">new</span> Date()).end().setYear(<span class="number">78</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="keyword">this</span>.start + <span class="string">" after "</span> + <span class="keyword">this</span>.end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新的构造方法和新的访问器，Period是真正不可变的。在可能的情况下，应该使用不可变对象作为对象的组件，如Period中使用LocalDateTime，就不用做防御性拷贝。<br><em><strong>防御性拷贝是在检查参数的有效性之前进行的</strong></em>，有效性检查是在拷贝上而不是在原始实例上进行的,这样检查参数和拷贝参数之间的漏洞窗口期间保护类不受其他线程对参数的更改的影响，这称为time-of-check/time-of-use 或 TOCTOU 攻击。</p><ul><li>如果拷贝的成本太高，并且类信任它的客户端不会不适当地修改组件，则可以用文档替换防御性拷贝，该文档概述了客户端不得修改受影响组件。</li></ul><h3 id="仔细设计方法签名">仔细设计方法签名</h3><ul><li>仔细选择方法名，选择与同一包中的其他名称一致且易于理解的名称，避免使用较长的方法名，可以参考 Java 类库API</li><li>不要过分地提供方便的方法，太多的方法使得类难以使用和维护，对于类或接口支持的每个操作，<br>提供一个功能完整的方法。</li><li>避免过长的参数列表，尽量是4个及以下的参数，过多的参数会使方法难以使用。有3种技术可以缩短列表<ul><li>创建辅助类保存参数组，这些辅助类通常是静态内部类。</li><li>将方法分解为多个方法，每个方法只需要参数的一个子集。例如List没有提供子列表中元素的第一个或最后一个索引位置，但是可以结合subList，indexOf，lastIndexOf使用。</li><li>Builder模式，定义一个对象来表示所有的参数，并允许客户端在这个对象上进行多个&quot;setter&quot; 调用，设置好所需的参数后，客户端调用对象的&quot;execute&quot;方法，该方法对参数进行最后的有效性检查，并执行实际的计算。</li></ul></li><li>与布尔型参数相比，优先使用两个元素枚举类型，除非布尔型参数的含义在方法名中是明确的。</li></ul><h3 id="明智审慎地使用重载">明智审慎地使用重载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Set"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; lst)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">                 <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">                 <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">                 <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">             System.out.println(classify(c));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>这个main方法将输出三次Unknown Collection，因为classify方法被重载了，<em><strong>在编译时选择要调用哪个重载方法。</strong></em></li><li>重载（overloaded）方法之间的选择是静态的，<em><strong>而重写（overridden）方法之间的选择是动态的。重写总是会执行“最具体 (most specific)”的重写方法。</strong></em></li><li>***一个安全和保守的策略是永远不要导出两个具有相同参数数量的重载，可以为方法赋予不同的名称，而不是重载它们。***例如ObjectOutputStream的writeBoolean(boolean)，writeFloat(float)。</li><li>类的多个构造函数总是被重载，可以使用静态工厂方法而不是构造。</li><li>不要在相同参数位置重载采用不同函数式接口的方法。例如Executors.submit(Callable),Executors.submit(Runnable)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool().submit(System.out::println)<span class="comment">//无法编译Ambiguous method</span></span><br></pre></td></tr></table></figure><p>Runnable.run()返回是void，println返回是void，看起来应该能编译，但并不能。</p><h3 id="明智审慎地使用可变参数">明智审慎地使用可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> arg : args)</span><br><span class="line">        sum += arg;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在需要参数数量可变的方法时，可变参数是有效的,在性能关键的情况下使用可变参数时要小心。每次调用可变参数方法都会导致数组分配和初始化。假设你已确定95％的调用是三个或更少的参数的方法，那么声明该方法的五个重载。例如guava的ImmutableMap静态工厂方法of。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3)</span><span class="params">( &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; ImmutableMap&lt;K, V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">ImmutableMap&lt;K, V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="返回空的数组或集合，不要返回-null">返回空的数组或集合，不要返回 null</h3><ul><li>在几乎每次使用返回 null 来代替空集合或数组的方法时，都需要判断非空。</li><li>如果有证据表明分配空集合会损害性能，可以通过重复返回相同的不可变空集合来避免分配，例如Collections.emptyList。</li></ul><h3 id="明智审慎地返回-Optional">明智审慎地返回 Optional</h3><ul><li>在 Java 8 中加入了 Optional&lt;T&gt;，返回Optional的方法比抛出异常的方法更灵活、更容易使用，而且比返回 null 的方法更不容易出错。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">Optional&lt;E&gt; <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>)</span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String lastWordInLexicon = max(words).orElse(<span class="string">"No words..."</span>);</span><br></pre></td></tr></table></figure><p>Optional很简单,Optional.empty() 返回一个空的 Optional， Optional.of(value)返回一个包含给定非null值的Optional，不要将null传入of方法，这将会抛出NullPointerException。<br><em><strong>永远不要通过返回 Optional 的方法返回一个null</strong></em>，这违反了Optional设计初衷。<br>Optional迫使用户面对可能没有返回值的事实，抛出未抛出未检查的异常或返回null允许用户忽略这种可能性，从而带来潜在的错误。抛出一个检查异常需要在客户端中添加额外的代码。</p><ul><li>容器类型，包括集合、映射、Stream、数组和Optional，不应该封装在Optional中，与其返回一个空的 Optional&lt;List<t>&gt; ，不还如返回一个空的 List<t>。</t></t></li><li>通常，<em><strong>如果可能无法返回结果，并且在没有返回结果，客户端还必须执行特殊处理的情况下，则应声明返回 Optional 的方法。</strong></em></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;检查参数有效性&quot;&gt;检查参数有效性&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;大多数方法和构造方法对可以将哪些值传递到其对应参数中有一些限制。例如，索引值必须是非负数。&lt;em&gt;&lt;strong&gt;在方法的开头检查参数，抛出适当的异常快速且清楚的结束方法&lt;/strong&gt;&lt;/em&gt;。如果不检查参数，可能会出现令人困惑的异常，或者方法正常返回，但计算错误。&lt;/li&gt;&lt;li&gt;可以使用guava的Preconditions检查参数。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
  </entry>
  
  <entry>
    <title>Lambdas和Streams</title>
    <link href="https://zhucj94.github.io/article/33749838.html"/>
    <id>https://zhucj94.github.io/article/33749838.html</id>
    <published>2020-03-28T09:40:14.000Z</published>
    <updated>2020-07-24T06:18:36.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优先使用标准的函数式接口">优先使用标准的函数式接口</h3><ul><li>有了lambda后，编写 API 的最佳实践已经发生了很大的变化，例如模板方法模式，其中一个子类重写原始方法以专门化其父类的行为，变得没有那么吸引人。现代替代的选择是提供一个静态工厂或构造方法来接受函数对象以达到相同的效果。<br>例如 LinkedHashMap，可以通过重写removeEldestEntry 方法将此类用作缓存，每次将新的key 值加入到 map时都会调用该方法，当此方法返回true时，map将删除传递给该方法的最久条目。</li></ul><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果LinkedHashMap是现在编写，可以用lambda来实现，增加一个构造或静态工厂方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BiPredicate&lt;Map&lt;K,V&gt;, Map.Entry&lt;K,V&gt;&gt; removeEldestEntry;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(BiPredicate&lt;Map&lt;K,V&gt;, Map.Entry&lt;K,V&gt;&gt; param)</span> </span>&#123;</span><br><span class="line">    removeEldestEntry = param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java.util.Function中有43个几口，但是只有6个基本接口，其余的均是其派生接口</li></ul><table><thead><tr><th style="text-align:center">接口</th><th style="text-align:center">方法</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">UnaryOperator&lt;T&gt;</td><td style="text-align:center">T apply(T t)</td><td style="text-align:center">String::toLowerCase</td></tr><tr><td style="text-align:center">BinaryOperator&lt;T&gt;</td><td style="text-align:center">T apply(T t1, T t2)</td><td style="text-align:center">BigInteger::add</td></tr><tr><td style="text-align:center">Predicate&lt;T&gt;</td><td style="text-align:center">boolean test(T t)</td><td style="text-align:center">Collection::isEmpty</td></tr><tr><td style="text-align:center">Function&lt;T,R&gt;</td><td style="text-align:center">R apply(T t)</td><td style="text-align:center">Arrays::asList</td></tr><tr><td style="text-align:center">Supplier&lt;T&gt;</td><td style="text-align:center">T get()</td><td style="text-align:center">Instant::now</td></tr><tr><td style="text-align:center">Consumer&lt;T&gt;</td><td style="text-align:center">void accept(T t)</td><td style="text-align:center">System.out::println</td></tr></tbody></table><ul><li>始终使用 @FunctionalInterface 注解标注你的函数式接口。<br>它告诉读者该接口是为了实现lambda表达式而设计的。<br>它使接口可靠，因为除非只有一个抽象方法，否则接口不会编译。<br>它可以防止维护人员在接口发生变化时不小心地将抽象方法添加到接口中。</li></ul><p>// TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;优先使用标准的函数式接口&quot;&gt;优先使用标准的函数式接口&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;有了lambda后，编写 API 的最佳实践已经发生了很大的变化，例如模板方法模式，其中一个子类重写原始方法以专门化其父类的行为，变得没有那么吸引人。现代替代的选择是提供一个静态工厂或构造方法来接受函数对象以达到相同的效果。&lt;br&gt;例如 LinkedHashMap，可以通过重写removeEldestEntry 方法将此类用作缓存，每次将新的key 值加入到 map时都会调用该方法，当此方法返回true时，map将删除传递给该方法的最久条目。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://zhucj94.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="effective java 3rd" scheme="https://zhucj94.github.io/tags/effective-java-3rd/"/>
    
  </entry>
  
</feed>
